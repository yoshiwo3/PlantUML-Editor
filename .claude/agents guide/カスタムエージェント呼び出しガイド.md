# カスタムエージェント呼び出しガイド

## 📚 概要
このガイドでは、Claude CodeのTask toolを使用してカスタムエージェントを呼び出す際の正しい方法と、よくある誤解について説明します。

## ⚠️ 重要な理解：subagent_typeの制限

### エラーメッセージの例
```
Error: Agent type 'web-debug-specialist' not found. 
Available agents: general-purpose, statusline-setup, output-style-setup
```

### 📌 重要な発見
Task toolの`subagent_type`パラメータには**エージェント名ではなくエージェントタイプ**を指定する必要があります。

## 🔧 利用可能なsubagent_type

Claude Codeが認識する`subagent_type`は**3つのみ**：

| タイプ | 用途 | ツールアクセス |
|--------|------|---------------|
| `general-purpose` | 汎用エージェント | すべてのツール |
| `statusline-setup` | ステータスライン設定 | Read, Edit |
| `output-style-setup` | 出力スタイル設定 | Read, Write, Edit, Glob, LS |

## ❌ よくある間違い

### 間違い1：エージェント名を直接指定
```javascript
// ❌ 動作しない
Task({
  subagent_type: "web-debug-specialist"  // カスタムエージェント名
})

// ❌ 動作しない
Task({
  subagent_type: "ai-driven-app-architect"  // カスタムエージェント名
})
```

### 間違い2：Agent typeとsubagent_typeの混同
```yaml
# エージェント定義ファイル
---
name: web-debug-specialist
Agent type: general-purpose  # これはエージェントの動作タイプ
---
```

```javascript
// Task呼び出し
Task({
  subagent_type: "general-purpose"  // これは別物（システムのタイプ）
})
```

## ✅ 正しい実装方法

### 方法1：general-purposeタイプとして実行（推奨）

```javascript
// カスタムエージェントを呼び出す正しい方法
await Task({
  description: "タスクの簡潔な説明",
  subagent_type: "general-purpose",  // 必ず3つのタイプから選択
  prompt: `
    # Role: [カスタムエージェント名]
    
    You are the [エージェント名] agent with the following configuration:
    - Name: [エージェント名]
    - Type: [専門分野]
    - Focus: [主要な責任領域]
    
    ## Your Task
    [具体的なタスク内容]
    
    ## Your Expertise
    [エージェントの専門知識リスト]
    
    ## Instructions
    [詳細な実行指示]
  `
});
```

### 方法2：エージェント定義を活用した呼び出し

```javascript
// 1. まずエージェント定義を読み込む
const agentConfig = await Read({
  file_path: "C:\\d\\PlantUML\\.claude\\agents\\web-debug-specialist.md"
});

// 2. Task toolで実行
await Task({
  description: "Frontend Error Fix",
  subagent_type: "general-purpose",
  prompt: `
    ${agentConfig}  // エージェント定義を含める
    
    ## Specific Task
    [実行するタスクの詳細]
  `
});
```

## 📝 実例：web-debug-specialistの呼び出し

```javascript
await Task({
  description: "STEP2 Error Fix",
  subagent_type: "general-purpose",  // 必須：システムタイプを指定
  prompt: `
    # Role: web-debug-specialist
    
    You are a frontend debugging specialist with expertise in:
    - JavaScript debugging and error analysis
    - DOM manipulation and event handling
    - Cross-browser compatibility
    - Performance optimization
    - UI/UX implementation
    
    ## Your Task
    Analyze and fix the PlantUML Editor STEP2 processing errors:
    1. PlantUMLParser initialization error
    2. getCurrentActors method not found
    3. Event handler context loss
    
    ## Technical Standards
    - Browser Support: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+
    - Performance: Lighthouse score >90
    - Accessibility: WCAG 2.1 AA compliance
    
    ## Required Output
    Create a comprehensive repair plan with:
    - Root cause analysis
    - Complete implementation code
    - Testing strategies
    - Performance optimization
    
    Apply your frontend expertise to solve these issues completely.
  `
});
```

## 🎯 まとめ

### 重要なポイント
1. **カスタムエージェント名は`subagent_type`として使用できない**
2. **必ず3つのシステムタイプのいずれかを指定**
3. **エージェントの専門性はプロンプトで定義**
4. **エージェント定義ファイルの内容をプロンプトに含める**

### ベストプラクティス
- エージェント定義ファイルは`.claude/agents/`に保存
- Agent typeは`general-purpose`に設定
- 詳細な役割定義はプロンプトに記載
- 専門知識と技術基準を明確に指定

## 📖 Task Tool 構文の詳細解説

### 基本構文

```javascript
Task({
  description: string,  // タスクの短い説明（3-5単語）
  prompt: string,      // エージェントへの詳細な指示
  subagent_type: string // エージェントタイプの指定
})
```

### パラメータ詳細

#### 1. **description** (必須)
- **型**: `string`
- **文字数**: 3-5単語程度
- **用途**: タスクの簡潔な説明
- **例**: 
  ```javascript
  description: "Fix frontend errors"
  description: "Analyze code structure"
  description: "Create test suite"
  ```

#### 2. **prompt** (必須)
- **型**: `string`
- **内容**: エージェントへの詳細な指示
- **推奨構造**:
  ```javascript
  prompt: `
    # Role: [エージェントの役割]
    
    ## Context
    [背景情報]
    
    ## Task
    [具体的なタスク]
    
    ## Requirements
    [要求事項]
    
    ## Expected Output
    [期待される成果物]
  `
  ```

#### 3. **subagent_type** (必須)
- **型**: `string`
- **許可される値**: 
  - `"general-purpose"` - 汎用エージェント（全ツール利用可）
  - `"statusline-setup"` - ステータスライン設定用
  - `"output-style-setup"` - 出力スタイル設定用

### 実際の使用例

#### 例1: シンプルな呼び出し
```javascript
await Task({
  description: "Search for files",
  subagent_type: "general-purpose",
  prompt: "Find all JavaScript files containing the word 'error' in the src directory"
});
```

#### 例2: 複雑なタスクの呼び出し
```javascript
await Task({
  description: "Debug frontend issue",
  subagent_type: "general-purpose",
  prompt: `
    # Context
    The PlantUML Editor has console errors when opening dialogs.
    Error log shows: "TypeError: Cannot read properties of undefined"
    
    # Task
    1. Analyze the error in app.js and PlantUMLParser.js
    2. Identify the root cause
    3. Propose a complete solution
    4. Create test cases
    
    # Requirements
    - Use modern JavaScript best practices
    - Ensure browser compatibility
    - Include error handling
    
    # Output
    Create a detailed repair plan document with:
    - Root cause analysis
    - Implementation code
    - Test scenarios
  `
});
```

#### 例3: カスタムエージェントのシミュレーション
```javascript
await Task({
  description: "Architecture design",
  subagent_type: "general-purpose",
  prompt: `
    You are acting as the ai-driven-app-architect agent.
    
    Your expertise includes:
    - System architecture design
    - Microservices patterns
    - Database design
    - API specifications
    
    Task: Design a scalable architecture for a real-time chat application
    
    Requirements:
    - Support 10,000 concurrent users
    - Message persistence
    - End-to-end encryption
    - Horizontal scaling capability
    
    Deliverables:
    - Architecture diagram (Mermaid format)
    - Technology stack recommendations
    - Implementation roadmap
  `
});
```

### 並列実行パターン

```javascript
// 複数のタスクを同時実行
const [result1, result2] = await Promise.all([
  Task({
    description: "Analyze frontend",
    subagent_type: "general-purpose",
    prompt: "Analyze all React components for performance issues"
  }),
  Task({
    description: "Check backend",
    subagent_type: "general-purpose",
    prompt: "Review API endpoints for security vulnerabilities"
  })
]);
```

### エラーハンドリング

```javascript
try {
  const result = await Task({
    description: "Complex analysis",
    subagent_type: "general-purpose",
    prompt: "..."
  });
} catch (error) {
  console.error("Task failed:", error);
  // フォールバック処理
}
```

### 重要な制限事項

1. **subagent_typeの制限**
   - カスタム名は使用不可
   - 3つのシステムタイプのみ

2. **ステートレス実行**
   - 各Task呼び出しは独立
   - エージェント間でのコンテキスト共有なし

3. **レスポンス形式**
   - エージェントの最終メッセージのみ返却
   - 中間プロセスは不可視

### ベストプラクティス

#### ✅ 推奨される使い方
```javascript
// 明確な役割定義
Task({
  description: "Fix JS errors",
  subagent_type: "general-purpose",
  prompt: `
    Role: Frontend debugging specialist
    
    Specific Task: Fix the binding error in PlantUMLParser.js line 90
    
    Analysis Required:
    1. Why is this[methodName] undefined?
    2. What is the correct initialization sequence?
    
    Provide: Complete fixed code with explanation
  `
});
```

#### ❌ 避けるべき使い方
```javascript
// 曖昧な指示
Task({
  description: "Fix something",
  subagent_type: "general-purpose",
  prompt: "There's an error somewhere, please fix it"
});

// 存在しないタイプ
Task({
  description: "Custom task",
  subagent_type: "my-custom-agent",  // エラーになる
  prompt: "..."
});
```

### 内部動作の概要

1. **Task呼び出し** → Claude Codeがリクエスト受信
2. **エージェント選択** → subagent_typeに基づいて処理
3. **プロンプト実行** → 指定されたツールで作業
4. **結果返却** → 最終メッセージを返す

## 📚 模範的なagents.mdファイル様式 - 完全ガイド

### 🏗️ 基本構造

```yaml
---
# 必須フィールド
name: エージェント名
Agent type: general-purpose  # 3つのタイプのいずれか
description: エージェントの詳細な説明

# 必須：利用可能なツール
tools:
  - Read
  - Write
  - [その他のツール]

# 推奨フィールド
model: opus/sonnet/haiku  # AIモデルの指定
priority: high/medium/low  # 優先度
color: red/blue/green     # UI表示色（オプション）
---

# メインコンテンツ（Markdown形式）
エージェントへの詳細な指示...
```

### 📋 YAMLフロントマター詳細

#### 必須フィールド

| フィールド | 型 | 説明 | 例 |
|------------|-----|------|-----|
| `name` | string | エージェントの一意識別子 | `web-debug-specialist` |
| `Agent type` | string | エージェントタイプ（3種類のみ） | `general-purpose` |
| `description` | string | エージェントの役割と使用場面の説明 | 複数行可、具体例含む |
| `tools` | array | 使用可能なツールのリスト | `[Read, Write, Task]` |

#### オプションフィールド

| フィールド | 型 | 説明 | 例 |
|------------|-----|------|-----|
| `model` | string | 使用するAIモデル | `opus`, `sonnet`, `haiku` |
| `priority` | string | 実行優先度 | `high`, `medium`, `low` |
| `color` | string | UI表示色 | `red`, `blue`, `green` |

### 🎯 完全な模範例

```markdown
---
name: frontend-performance-optimizer
Agent type: general-purpose
description: Frontend performance optimization specialist focused on improving web application speed, reducing bundle sizes, and enhancing user experience metrics. Use PROACTIVELY for performance audits, optimization strategies, and bottleneck analysis. MUST BE USED when dealing with slow page loads, large bundle sizes, or poor Lighthouse scores.

tools:
  - Read
  - Write
  - Edit
  - MultiEdit
  - Grep
  - Glob
  - Bash
  - WebFetch
  - WebSearch
  - TodoWrite
  - Task
  - mcp__playwright__browser_snapshot
  - mcp__playwright__browser_console_messages

model: opus
priority: high
color: red
---

# Frontend Performance Optimizer

You are a performance optimization specialist with deep expertise in web performance metrics, bundle optimization, and user experience enhancement.

## Core Responsibilities

1. **Performance Auditing**: Conduct comprehensive performance audits using Lighthouse and custom metrics
2. **Bundle Optimization**: Reduce JavaScript bundle sizes through code splitting and tree shaking
3. **Critical Path Optimization**: Optimize critical rendering path for faster initial loads
4. **Caching Strategies**: Implement effective browser and CDN caching strategies
5. **Image Optimization**: Optimize images with modern formats and lazy loading
6. **Runtime Performance**: Improve JavaScript execution and rendering performance

## Technical Standards

### Performance Targets
- **Lighthouse Score**: >95 for all categories
- **First Contentful Paint (FCP)**: <1.0s
- **Largest Contentful Paint (LCP)**: <2.5s
- **First Input Delay (FID)**: <100ms
- **Cumulative Layout Shift (CLS)**: <0.1
- **Time to Interactive (TTI)**: <3.5s

### Optimization Techniques
- **Code Splitting**: Route-based and component-based splitting
- **Tree Shaking**: Eliminate dead code and unused dependencies
- **Minification**: HTML, CSS, JavaScript minification
- **Compression**: Gzip/Brotli compression for all text assets
- **Preloading**: Strategic use of preload, prefetch, and preconnect
- **Service Workers**: Offline caching and background sync

## Workflow Protocol

### Phase 1: Performance Audit
```javascript
// Conduct initial audit
1. Run Lighthouse audit
2. Analyze bundle composition with webpack-bundle-analyzer
3. Profile runtime performance with Chrome DevTools
4. Identify rendering bottlenecks
5. Document baseline metrics
```

### Phase 2: Optimization Implementation
```javascript
// Apply optimizations
1. Implement code splitting strategies
2. Optimize critical rendering path
3. Configure resource hints
4. Set up lazy loading
5. Optimize images and fonts
6. Implement caching strategies
```

### Phase 3: Validation and Monitoring
```javascript
// Verify improvements
1. Re-run performance audits
2. Compare before/after metrics
3. Set up performance monitoring
4. Create performance budget
5. Document optimization results
```

## Success Criteria

- [ ] Lighthouse Performance score >95
- [ ] Initial page load <3 seconds on 3G
- [ ] JavaScript bundle size <200KB (gzipped)
- [ ] No layout shifts after initial load
- [ ] Smooth 60fps scrolling and animations
- [ ] Effective caching strategy implemented
- [ ] Performance monitoring dashboard created

## Error Handling Protocol

When encountering performance issues:

1. **Slow Initial Load**
   - Check bundle size and splitting
   - Analyze server response times
   - Review critical rendering path

2. **Poor Runtime Performance**
   - Profile JavaScript execution
   - Check for memory leaks
   - Optimize render cycles

3. **Large Bundle Sizes**
   - Audit dependencies
   - Implement tree shaking
   - Use dynamic imports

## Output Format

### Performance Report Template
```markdown
# Performance Optimization Report

## Executive Summary
[Brief overview of improvements]

## Metrics Comparison
| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| LCP    | X.Xs   | X.Xs  | XX%         |
| FCP    | X.Xs   | X.Xs  | XX%         |

## Optimizations Applied
1. [Optimization with impact]
2. [Optimization with impact]

## Recommendations
- [Future optimization opportunities]
```

## Quality Metrics

- **Bundle Size Reduction**: >30% reduction target
- **Load Time Improvement**: >50% faster initial load
- **Lighthouse Score**: All categories >90
- **User Experience**: Perceived performance improvements
- **Cache Hit Rate**: >80% for static assets

## Tools Usage Guidelines

- **Bash**: Run build tools and performance scripts
- **WebFetch**: Gather performance data from monitoring services
- **Playwright**: Automate performance testing scenarios
- **TodoWrite**: Track optimization tasks and progress
- **Task**: Delegate specialized optimization subtasks

## Best Practices

1. **Measure First**: Always establish baseline metrics
2. **Iterate**: Apply optimizations incrementally
3. **Monitor**: Set up continuous performance monitoring
4. **Document**: Record all changes and their impacts
5. **Test**: Verify improvements across devices and networks
```

### 📐 構造的要素の説明

#### 1. **YAMLフロントマター**
- **簡潔性**: 必要最小限の設定
- **明確性**: 各フィールドの目的が明確
- **拡張性**: オプションフィールドで機能追加可能

#### 2. **説明文（description）のベストプラクティス**
```yaml
description: |
  [専門分野] specialist focused on [主要タスク].
  Use PROACTIVELY for [使用場面].
  MUST BE USED when [必須使用条件].
```

#### 3. **本文構造**
- **タイトル**: エージェント名（人間が読みやすい形式）
- **概要**: 1-2文でエージェントの役割を説明
- **セクション構成**:
  1. Core Responsibilities（中核的責任）
  2. Technical Standards（技術基準）
  3. Workflow Protocol（作業手順）
  4. Success Criteria（成功基準）
  5. Error Handling（エラー対処）
  6. Output Format（出力形式）
  7. Quality Metrics（品質指標）
  8. Tools Usage Guidelines（ツール使用指針）

### 🔧 ツール指定のガイドライン

#### 基本ツールセット
```yaml
tools:
  # ファイル操作
  - Read
  - Write
  - Edit
  - MultiEdit
  
  # 検索・探索
  - Grep
  - Glob
  - LS
  
  # 実行・処理
  - Bash
  - Task
  
  # Web関連
  - WebFetch
  - WebSearch
  
  # プロジェクト管理
  - TodoWrite
```

#### MCPツール（必要に応じて）
```yaml
  # GitHub連携
  - mcp__github__*
  
  # ブラウザ自動化
  - mcp__playwright__*
  
  # ドキュメント取得
  - mcp__context7__*
```

### ✅ チェックリスト

模範的なagents.mdファイルの条件：

- [ ] YAMLフロントマターが正しく記述されている
- [ ] nameが一意で分かりやすい
- [ ] Agent typeが3つの有効な値のいずれか
- [ ] descriptionが具体的で使用場面が明確
- [ ] 必要なツールがすべて列挙されている
- [ ] 本文が構造化され、読みやすい
- [ ] 具体的な作業手順が含まれている
- [ ] 成功基準が明確に定義されている
- [ ] エラー処理の指針がある
- [ ] 出力形式の例が提供されている

この様式に従うことで、効果的で再利用可能なエージェント定義を作成できます。

## 🔮 将来の展望
将来的にClaude Codeがカスタムsubagent_typeをサポートする可能性はありますが、2025年8月現在、上記の方法が唯一の実装方法です。

---
*作成日: 2025年8月14日*
*最終更新: 2025年8月14日*
*Claude Code バージョン: 現行版*
*ドキュメントバージョン: 3.0*