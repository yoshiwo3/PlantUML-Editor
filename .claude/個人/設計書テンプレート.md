# 統合型設計書テンプレート【完全版】
## AI駆動アジャイル開発×エージェント協調×抜け漏れゼロ

---

## 🎯 このテンプレートの3つの特徴

### 1. **抜け漏れゼロ保証**
- 設計書必須要素の完全網羅
- 自動検証による漏れ検出
- 100点達成まで反復改善

### 2. **AI駆動アジャイル対応**
- 既存プロジェクトへの段階的追加
- 小さな変更の積み重ね
- 継続的改善サイクル

### 3. **マルチエージェント協調**
- 専門エージェントによる並列作業
- 品質の相互チェック
- 効率的な役割分担

---

## 📋 使用方法と対応範囲

### 📊 このテンプレートの対応範囲
| 開発タイプ | 対応度 | 推奨度 | 特徴 |
|-----------|--------|--------|------|
| **初期開発**（新規） | ◎ | ★★★★★ | フル機能で完全対応 |
| **追加開発**（既存） | ◎ | ★★★★★ | AI駆動アジャイルで最適化 |
| **バグ修正**（緊急） | ○ | ★★★☆☆ | 軽量モードで対応可能 |
| **リファクタリング** | ◎ | ★★★★☆ | 段階的改善に最適 |

### 🎯 開発タイプ別の使い分けガイド

#### 【初期開発】新規アプリケーション（ゼロから構築）
```
使用セクション:
- Part A: 全セクション（1-5）を使用
- Part B: Stage 1-3すべて実行（8エージェント並列）
- Part C: 100点達成まで完全検証

実行コマンド:
「統合型設計書テンプレートで新規アプリケーション[名前]の設計書を作成してください。
初期開発モードで全機能を実装し、100点の品質を達成してください。」

所要時間: 4-6時間
```

#### 【追加開発】既存プロジェクトへの機能追加
```
使用セクション:
- Part A: セクション1,2,3,5を使用（※2は追加部分のみ設計）
- Part B: Stage 2-3のみ実行（5エージェント）
- Part C: 影響範囲を重点検証

実行コマンド:
「統合型設計書テンプレートのAI駆動アジャイル開発アプローチで
[機能名]を既存プロジェクトに追加してください。
新機能の設計仕様を明確にし、既存機能との連携を設計してください。」

所要時間: 2-3時間
```

#### 【バグ修正】緊急対応
```
使用セクション:
- Part A: セクション1,4のみ
- Part B: Stage 3のみ（2エージェント）
- Part C: 簡易検証

実行コマンド:
「統合型設計書テンプレートの緊急修正モードで
[バグ内容]を修正してください。
最小限の変更で問題を解決してください。」

所要時間: 1時間
```

#### 【ハイブリッド】大規模リニューアル
```
使用セクション:
- Part A: 全セクション（段階的に適用）
- Part B: 全Stage（必要に応じて反復）
- Part C: 段階ごとに検証

実行コマンド:
「既存の[プロジェクト名]を大幅リニューアルするため、
統合型設計書テンプレートのフル機能版を使用してください。
段階的に品質を向上させながら実装してください。」

所要時間: 8-12時間（段階的実施）
```

### 🔄 柔軟な適用パターン

#### パターン1: スピード重視（1-2時間）
```
Part A: セクション1,2（簡潔版）,3のみ → Part B: Stage 3のみ → Part C: 簡易検証
```

#### パターン2: バランス重視（3-4時間）
```
Part A: セクション1,2,3,5（※4は省略可） → Part B: Stage 2,3 → Part C: 標準検証
```

#### パターン3: 品質重視（5-6時間）
```
Part A: 全セクション → Part B: 全Stage → Part C: 完全検証（100点）
```

---

# Part A: 設計書本体【必須要素】

## 1. 要件定義【What】

### 1.1 機能概要
```yaml
機能名: [機能の正式名称]
バージョン: [v1.0.0]
種別: [新規追加/変更/修正/削除]
優先度: [高/中/低]
```

### 1.2 背景と目的
```
解決する問題:
- [ユーザーが抱える具体的な問題]
- [現状の課題]

提供する価値:
- [ユーザーメリット]
- [ビジネス価値]

成功基準（測定可能）:
□ [定量的な指標1]
□ [定量的な指標2]
□ [定量的な指標3]
```

### 1.3 機能要件【完全リスト】
```
必須機能:
□ F001: [機能説明]
□ F002: [機能説明]
□ F003: [機能説明]
□ F004: [機能説明]
□ F005: [機能説明]

オプション機能:
□ F101: [機能説明]
□ F102: [機能説明]
```

### 1.4 非機能要件
```
パフォーマンス:
- レスポンス時間: [X]ms以内
- 同時接続数: [Y]件
- スループット: [Z]req/sec

セキュリティ:
- 認証: [方式]
- 認可: [レベル]
- データ暗号化: [要/不要]

信頼性:
- 可用性: [99.9%]
- 復旧時間: [X分以内]
- データ整合性: [保証レベル]
```

---

## 2. 設計仕様【How】
*※追加開発の場合：新機能部分と既存システムとの連携を中心に記載*

### 2.1 アーキテクチャ設計
```
システム構成:
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Frontend   │────▶│   Backend   │────▶│  Database   │
│   (View)    │◀────│  (Logic)    │◀────│   (Data)    │
└─────────────┘     └─────────────┘     └─────────────┘
       ↓                   ↓                   ↓
   [詳細記載]          [詳細記載]          [詳細記載]
```

### 2.2 データ設計
```javascript
// データモデル定義
const DataSchema = {
    // メインエンティティ
    Entity: {
        id: { type: 'string', required: true },
        name: { type: 'string', required: true },
        // ... 全フィールド定義
    },
    
    // リレーション
    Relations: {
        hasMany: [],
        belongsTo: [],
        manyToMany: []
    }
};

// 状態遷移
const StateTransitions = {
    initial: 'draft',
    states: {
        draft: { next: ['published', 'deleted'] },
        published: { next: ['draft', 'archived'] },
        archived: { next: ['deleted'] },
        deleted: { next: [] }
    }
};
```

### 2.3 インターフェース設計
```typescript
// API定義（内部）
interface InternalAPI {
    // エンドポイント
    GET /api/resources: ResourceList;
    GET /api/resources/:id: Resource;
    POST /api/resources: Resource;
    PUT /api/resources/:id: Resource;
    DELETE /api/resources/:id: void;
}

// 外部API連携仕様
interface ExternalAPIConfig {
    // 基本設定
    baseURL: string;              // 例: 'https://api.example.com/v1'
    timeout: number;              // 例: 30000 (30秒)
    retryCount: number;           // 例: 3
    retryDelay: number;           // 例: 1000 (1秒)
    
    // 認証設定
    auth: {
        type: 'Bearer' | 'OAuth2' | 'APIKey' | 'Basic';
        credentials: {
            token?: string;
            clientId?: string;
            clientSecret?: string;
            apiKey?: string;
        };
    };
    
    // レート制限
    rateLimit: {
        requests: number;         // 例: 100
        window: number;          // 例: 60000 (1分間に100リクエスト)
    };
}

// 外部API実装例
class ExternalAPIClient {
    private queue: Promise<any>[] = [];
    private rateLimiter: RateLimiter;
    
    constructor(private config: ExternalAPIConfig) {
        this.rateLimiter = new RateLimiter(config.rateLimit);
    }
    
    async request(options: RequestOptions): Promise<any> {
        // レート制限チェック
        await this.rateLimiter.acquire();
        
        // リトライロジック
        let lastError;
        for (let i = 0; i <= this.config.retryCount; i++) {
            try {
                const response = await this.executeRequest(options);
                return response;
            } catch (error) {
                lastError = error;
                if (i < this.config.retryCount) {
                    await this.delay(this.config.retryDelay * Math.pow(2, i)); // 指数バックオフ
                }
            }
        }
        throw lastError;
    }
    
    private async executeRequest(options: RequestOptions) {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), this.config.timeout);
        
        try {
            const response = await fetch(`${this.config.baseURL}${options.path}`, {
                method: options.method,
                headers: this.buildHeaders(options),
                body: options.body ? JSON.stringify(options.body) : undefined,
                signal: controller.signal
            });
            
            if (!response.ok) {
                throw new APIError(response.status, await response.text());
            }
            
            return await response.json();
        } finally {
            clearTimeout(timeout);
        }
    }
    
    private buildHeaders(options: RequestOptions): Headers {
        const headers = new Headers(options.headers);
        
        // 認証ヘッダー追加
        switch (this.config.auth.type) {
            case 'Bearer':
                headers.set('Authorization', `Bearer ${this.config.auth.credentials.token}`);
                break;
            case 'APIKey':
                headers.set('X-API-Key', this.config.auth.credentials.apiKey);
                break;
            // ... 他の認証タイプ
        }
        
        return headers;
    }
}

// Webhook受信仕様
interface WebhookConfig {
    endpoint: '/webhooks/[provider]';
    method: 'POST';
    verification: {
        type: 'HMAC' | 'Signature' | 'Token';
        secret: string;
    };
    events: string[];           // 例: ['payment.completed', 'user.created']
    retryPolicy: {
        maxAttempts: number;
        backoffMultiplier: number;
    };
}

// リクエスト/レスポンス
interface Resource {
    id: string;
    name: string;
    // ... 全プロパティ
}

// エラー定義（詳細化）
interface ErrorResponse {
    code: string;               // 例: 'E10001'
    message: string;            // ユーザー向けメッセージ
    details?: {
        field?: string;         // エラーフィールド
        reason?: string;        // 技術的理由
        suggestion?: string;    // 改善提案
    };
    timestamp: string;
    traceId: string;           // トレース用ID
}
```

### 2.4 非同期処理パターン
```javascript
// 1. Promise基本パターン
class AsyncProcessor {
    // 単一非同期処理
    async processItem(item) {
        try {
            const result = await this.validateItem(item);
            const processed = await this.transformItem(result);
            await this.saveItem(processed);
            return { success: true, data: processed };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
    
    // 並列処理（すべて成功が必要）
    async processAllOrFail(items) {
        try {
            const results = await Promise.all(
                items.map(item => this.processItem(item))
            );
            return results;
        } catch (error) {
            throw new Error('One or more items failed to process');
        }
    }
    
    // 並列処理（部分的失敗を許容）
    async processAllSettled(items) {
        const results = await Promise.allSettled(
            items.map(item => this.processItem(item))
        );
        
        const succeeded = results.filter(r => r.status === 'fulfilled');
        const failed = results.filter(r => r.status === 'rejected');
        
        return {
            succeeded: succeeded.map(r => r.value),
            failed: failed.map(r => r.reason),
            successRate: (succeeded.length / results.length) * 100
        };
    }
    
    // 競争処理（最初の成功を採用）
    async processRace(sources) {
        return await Promise.race(
            sources.map(source => this.fetchFromSource(source))
        );
    }
}

// 2. キュー処理パターン
class QueueProcessor {
    constructor(concurrency = 5) {
        this.queue = [];
        this.running = 0;
        this.concurrency = concurrency;
    }
    
    async add(task) {
        return new Promise((resolve, reject) => {
            this.queue.push({ task, resolve, reject });
            this.process();
        });
    }
    
    async process() {
        if (this.running >= this.concurrency || this.queue.length === 0) {
            return;
        }
        
        this.running++;
        const { task, resolve, reject } = this.queue.shift();
        
        try {
            const result = await task();
            resolve(result);
        } catch (error) {
            reject(error);
        } finally {
            this.running--;
            this.process(); // 次のタスクを処理
        }
    }
}

// 3. ストリーム処理パターン
class StreamProcessor {
    async* processStream(dataStream) {
        for await (const chunk of dataStream) {
            // チャンクごとに処理
            const processed = await this.processChunk(chunk);
            yield processed;
        }
    }
    
    async consumeStream(dataStream) {
        const results = [];
        for await (const data of this.processStream(dataStream)) {
            results.push(data);
            
            // バックプレッシャー制御
            if (results.length >= 100) {
                await this.flushResults(results);
                results.length = 0;
            }
        }
        
        // 残りをフラッシュ
        if (results.length > 0) {
            await this.flushResults(results);
        }
    }
}

// 4. イベント駆動非同期パターン
class EventDrivenProcessor extends EventEmitter {
    constructor() {
        super();
        this.setupEventHandlers();
    }
    
    setupEventHandlers() {
        // エラーハンドリング
        this.on('error', (error) => {
            console.error('Processing error:', error);
            this.handleError(error);
        });
        
        // 進捗報告
        this.on('progress', (progress) => {
            console.log(`Progress: ${progress.current}/${progress.total}`);
        });
        
        // 完了通知
        this.on('complete', (result) => {
            console.log('Processing complete:', result);
        });
    }
    
    async processWithEvents(data) {
        try {
            for (let i = 0; i < data.length; i++) {
                await this.processItem(data[i]);
                this.emit('progress', { current: i + 1, total: data.length });
            }
            this.emit('complete', { processed: data.length });
        } catch (error) {
            this.emit('error', error);
        }
    }
}

// 5. デバウンス/スロットルパターン
class RateLimitedProcessor {
    constructor() {
        this.debounceTimers = new Map();
        this.throttleLastCall = new Map();
    }
    
    // デバウンス（最後の呼び出しのみ実行）
    debounce(key, func, delay) {
        clearTimeout(this.debounceTimers.get(key));
        
        return new Promise((resolve) => {
            const timer = setTimeout(async () => {
                const result = await func();
                resolve(result);
            }, delay);
            
            this.debounceTimers.set(key, timer);
        });
    }
    
    // スロットル（一定間隔で実行）
    async throttle(key, func, interval) {
        const lastCall = this.throttleLastCall.get(key) || 0;
        const now = Date.now();
        
        if (now - lastCall < interval) {
            await new Promise(resolve => 
                setTimeout(resolve, interval - (now - lastCall))
            );
        }
        
        this.throttleLastCall.set(key, Date.now());
        return await func();
    }
}

// 6. リトライパターン
class RetryableProcessor {
    async withRetry(func, options = {}) {
        const {
            maxAttempts = 3,
            delay = 1000,
            backoff = 2,
            shouldRetry = (error) => true
        } = options;
        
        let lastError;
        
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                return await func();
            } catch (error) {
                lastError = error;
                
                if (attempt === maxAttempts || !shouldRetry(error)) {
                    throw error;
                }
                
                const waitTime = delay * Math.pow(backoff, attempt - 1);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
        
        throw lastError;
    }
}

// 7. タイムアウトパターン
class TimeoutProcessor {
    async withTimeout(promise, timeout) {
        return Promise.race([
            promise,
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Operation timed out')), timeout)
            )
        ]);
    }
    
    async processWithTimeout(data, timeout = 5000) {
        try {
            return await this.withTimeout(
                this.longRunningProcess(data),
                timeout
            );
        } catch (error) {
            if (error.message === 'Operation timed out') {
                // タイムアウト時の処理
                return this.handleTimeout(data);
            }
            throw error;
        }
    }
}

// 8. バッチ処理パターン
class BatchProcessor {
    constructor(batchSize = 10) {
        this.batchSize = batchSize;
        this.batch = [];
        this.batchTimer = null;
        this.batchTimeout = 1000; // 1秒でフラッシュ
    }
    
    async add(item) {
        this.batch.push(item);
        
        if (this.batch.length >= this.batchSize) {
            return await this.flush();
        }
        
        // タイマーリセット
        if (this.batchTimer) {
            clearTimeout(this.batchTimer);
        }
        
        this.batchTimer = setTimeout(() => this.flush(), this.batchTimeout);
    }
    
    async flush() {
        if (this.batch.length === 0) return;
        
        const items = [...this.batch];
        this.batch = [];
        
        return await this.processBatch(items);
    }
    
    async processBatch(items) {
        // バッチ処理の実装
        console.log(`Processing batch of ${items.length} items`);
        return items;
    }
}
```

### 2.5 UI/UX設計
```
画面遷移:
[画面A] ─クリック→ [画面B] ─送信→ [画面C]
   ↓                  ↑
   └──────戻る────────┘

画面要素:
- ヘッダー: [要素リスト]
- メイン: [要素リスト]
- フッター: [要素リスト]

インタラクション:
- クリック: [動作定義]
- 入力: [バリデーション]
- ドラッグ: [挙動定義]
```

---

## 3. 実装計画【When/Who】

### 3.1 影響範囲分析
```
変更ファイル:
□ 既存ファイル
  - file1.js: [変更内容]
  - file2.js: [変更内容]
□ 新規ファイル
  - newFile.js: [作成理由]

依存関係:
- 外部ライブラリ: [名前:バージョン]
- 内部モジュール: [モジュール名]
- API: [エンドポイント]

影響を受ける機能:
- 機能A: [影響内容]
- 機能B: [影響内容]
```

### 3.2 実装フェーズ
```
Phase 1: 基盤（1-2時間）
□ データモデル作成
□ APIエンドポイント実装
□ 基本的なエラーハンドリング

Phase 2: 機能実装（2-4時間）
□ コア機能の実装
□ UI/フロントエンド実装
□ データ処理ロジック

Phase 3: 品質保証（1-2時間）
□ 単体テスト作成
□ 統合テスト作成
□ E2Eテスト（必要時）

Phase 4: 最終調整（30分-1時間）
□ コードレビュー対応
□ ドキュメント更新
□ デプロイ準備
```

---

## 4. リスク管理【What if】

### 4.1 技術的リスク
```
リスク項目:
1. パフォーマンス劣化
   - 発生確率: 中
   - 影響度: 高
   - 対策: インデックス最適化、キャッシュ実装

2. 既存機能への影響
   - 発生確率: 低
   - 影響度: 高
   - 対策: 段階的リリース、フィーチャーフラグ

3. セキュリティ脆弱性
   - 発生確率: 低
   - 影響度: 極高
   - 対策: セキュリティレビュー、ペネトレーションテスト
```

### 4.2 エラーケース対応
```javascript
// エラーケース一覧と対処
const ErrorHandling = {
    // 入力エラー
    INVALID_INPUT: {
        code: 'E001',
        message: '入力値が不正です',
        action: 'バリデーションメッセージ表示'
    },
    
    // システムエラー
    SYSTEM_ERROR: {
        code: 'E500',
        message: 'システムエラーが発生しました',
        action: 'ログ記録、管理者通知、フォールバック'
    },
    
    // ネットワークエラー
    NETWORK_ERROR: {
        code: 'E503',
        message: 'ネットワークエラー',
        action: 'リトライ、オフライン処理'
    }
};
```

---

## 5. テスト設計【Verify】

### 5.1 テスト戦略
```
テストレベル:
1. 単体テスト
   - カバレッジ目標: 80%以上
   - 対象: 全public関数
   - ツール: Jest

2. 統合テスト
   - カバレッジ目標: 60%以上
   - 対象: API、データフロー
   - ツール: Jest + Supertest

3. E2Eテスト
   - カバレッジ: 主要シナリオ
   - 対象: ユーザーフロー
   - ツール: Playwright
```

### 5.2 テストケース
```javascript
// 単体テストケース
describe('機能名', () => {
    test('正常系: 期待される動作', () => {
        // Arrange
        const input = 'test';
        
        // Act
        const result = targetFunction(input);
        
        // Assert
        expect(result).toBe('expected');
    });
    
    test('異常系: エラーハンドリング', () => {
        expect(() => targetFunction(null))
            .toThrow('Invalid input');
    });
    
    test('境界値: エッジケース', () => {
        expect(targetFunction('')).toBe([]);
        expect(targetFunction(undefined)).toBe([]);
    });
});
```

---

# Part B: エージェント協調実装

## Stage 1: 設計分析（3エージェント並列）
```javascript
await Promise.all([
    // 要件分析エージェント
    Task({
        description: "要件分析",
        subagent_type: "general-purpose",
        prompt: `
            # Role: Requirements Analyst
            Part Aのセクション1（要件定義）を完成させてください：
            1. 機能要件の完全なリスト化
            2. 非機能要件の定量化
            3. 成功基準の設定
            4. 抜け漏れチェック
        `
    }),
    
    // アーキテクト
    Task({
        description: "設計仕様",
        subagent_type: "general-purpose",
        prompt: `
            # Role: Solution Architect
            Part Aのセクション2（設計仕様）を完成させてください：
            1. アーキテクチャ設計
            2. データモデル設計
            3. インターフェース定義
            4. 技術選定と根拠
        `
    }),
    
    // リスク分析エージェント
    Task({
        description: "リスク分析",
        subagent_type: "general-purpose",
        prompt: `
            # Role: Risk Analyst
            Part Aのセクション4（リスク管理）を完成させてください：
            1. 技術的リスクの特定
            2. ビジネスリスクの評価
            3. 対策の立案
            4. エラーケース網羅
        `
    })
]);
```

## Stage 2: 実装（4エージェント並列）
```javascript
await Promise.all([
    // バックエンド実装
    Task({
        description: "バックエンド実装",
        subagent_type: "general-purpose",
        prompt: `
            # Role: Backend Developer
            設計書に基づいてバックエンドを実装：
            1. データモデル実装
            2. APIエンドポイント作成
            3. ビジネスロジック実装
            4. エラーハンドリング
        `
    }),
    
    // フロントエンド実装
    Task({
        description: "フロントエンド実装",
        subagent_type: "general-purpose",
        prompt: `
            # Role: Frontend Developer
            設計書に基づいてUIを実装：
            1. UIコンポーネント作成
            2. 状態管理実装
            3. APIとの連携
            4. レスポンシブ対応
        `
    }),
    
    // テスト実装
    Task({
        description: "テスト実装",
        subagent_type: "general-purpose",
        prompt: `
            # Role: Test Engineer
            Part Aのセクション5に基づいてテスト作成：
            1. 単体テスト実装
            2. 統合テスト実装
            3. E2Eシナリオ作成
            4. テストデータ準備
        `
    }),
    
    // ドキュメント作成
    Task({
        description: "ドキュメント作成",
        subagent_type: "general-purpose",
        prompt: `
            # Role: Technical Writer
            ドキュメントを作成：
            1. API仕様書
            2. 実装ガイド
            3. 運用手順書
            4. トラブルシューティング
        `
    })
]);
```

## Stage 3: 品質保証（2エージェント順次）
```javascript
// レビューと改善
const reviewResult = await Task({
    description: "コードレビュー",
    subagent_type: "general-purpose",
    prompt: `
        # Role: Senior Developer
        全実装をレビュー：
        1. コード品質チェック
        2. 設計書との整合性確認
        3. セキュリティ監査
        4. パフォーマンス評価
    `
});

// 最終検証
await Task({
    description: "最終検証",
    subagent_type: "general-purpose",
    prompt: `
        # Role: QA Lead
        品質検証と改善：
        1. 機能要件の充足確認
        2. テスト実行と結果確認
        3. 抜け漏れチェック
        4. リリース判定
        レビュー結果: ${reviewResult}
    `
});
```

---

# Part C: 品質検証【100点保証】

## 設計書完全性チェックリスト

### 必須要素確認（各10点）
```
要件定義:
□ 背景と目的が明確 (10点)
□ 機能要件が網羅的 (10点)
□ 非機能要件が定量的 (10点)

設計仕様:
□ アーキテクチャが明確 (10点)
□ データ設計が完全 (10点)
□ インターフェースが定義済み (10点)

実装:
□ 影響範囲が特定済み (10点)
□ 実装計画が現実的 (10点)

品質:
□ リスク対策が明確 (10点)
□ テスト戦略が適切 (10点)

スコア: ___/100点
```

### 抜け漏れ検証アルゴリズム
```javascript
class DesignCompleteness {
    validate(design) {
        const checks = {
            requirements: this.checkRequirements(design),
            architecture: this.checkArchitecture(design),
            implementation: this.checkImplementation(design),
            testing: this.checkTesting(design),
            risks: this.checkRisks(design)
        };
        
        const score = Object.values(checks)
            .filter(v => v).length * 20;
        
        const missing = Object.entries(checks)
            .filter(([k, v]) => !v)
            .map(([k]) => k);
        
        return {
            score,
            missing,
            complete: score >= 100
        };
    }
    
    checkRequirements(design) {
        return design.requirements && 
               design.requirements.functional.length >= 5 &&
               design.requirements.nonFunctional !== undefined;
    }
    
    checkArchitecture(design) {
        return design.architecture && 
               design.dataModel && 
               design.interfaces;
    }
    
    checkImplementation(design) {
        return design.impactAnalysis && 
               design.phases && 
               design.dependencies;
    }
    
    checkTesting(design) {
        return design.testStrategy && 
               design.testCases && 
               design.coverage >= 80;
    }
    
    checkRisks(design) {
        return design.risks && 
               design.risks.length > 0 &&
               design.errorHandling;
    }
}
```

### 改善サイクル
```
1. 初回作成
   ↓
2. 検証実行（スコア算出）
   ↓
3. 不足項目の特定
   missing: ['requirements', 'testing']
   ↓
4. 該当エージェントに追加作業依頼
   ↓
5. 再検証（100点まで繰り返し）
   ↓
6. 完成
```

---

# Part D: 実践ガイド

## 📊 他テンプレートとの比較・使い分け

### テンプレート選択ガイド
| テンプレート | 初期開発 | 追加開発 | 特徴 | 推奨シーン |
|------------|---------|---------|------|-----------|
| **統合型設計書テンプレート_完全版.md**（本書） | ◎ | ◎ | 両方に最適化、3つのコンセプト統合 | すべての開発で推奨 |
| **AI駆動開発用_機能追加テンプレート.md** | △ | ◎ | 既存プロジェクトへの追加に特化 | 既存システムへの小規模追加 |
| **実践的設計書テンプレート.md** | ◎ | ○ | 新規開発向け、完全実装重視 | ゼロからの新規開発 |
| **設計書テンプレート_シンプル版.md** | ○ | ○ | 初心者向け、わかりやすさ重視 | 学習・小規模プロジェクト |

### 使い分けの判断基準
```
Q: プロジェクトは新規？既存？
├─ 新規 → 統合型（本書）または実践的設計書
└─ 既存 → 統合型（本書）またはAI駆動開発用

Q: 開発規模は？
├─ 大規模 → 統合型（本書）フル機能
├─ 中規模 → 統合型（本書）標準モード
└─ 小規模 → AI駆動開発用またはシンプル版

Q: 品質要求は？
├─ 高品質（100点） → 統合型（本書）
├─ 標準（80点） → AI駆動開発用
└─ 速度優先 → シンプル版
```

## ケース別使用方法（詳細版）

### ケース1: 新規プロジェクト立ち上げ
```
状況: ゼロからアプリケーションを構築
推奨: 統合型テンプレート・初期開発モード

手順:
1. Part A: 全セクション（1-5）記載
2. Part B: Stage 1-3すべて実行（8エージェント）
3. Part C: 100点達成まで検証

実行例:
「統合型設計書テンプレートで新規ECサイトの設計書を作成してください。
初期開発モードですべての要素を網羅し、100点の品質を達成してください。」

所要時間: 4-6時間
成果物: 完全な設計書、実装コード、テスト、ドキュメント
```

### ケース2: 既存システムへの機能追加
```
状況: 運用中のシステムに新機能を追加
推奨: 統合型テンプレート・追加開発モード

手順:
1. Part A: セクション1,2,3,5を記載
   - セクション1: 追加機能の要件定義
   - セクション2: 新機能の設計仕様と既存システムとの連携設計
   - セクション3: 実装計画と影響範囲分析
   - セクション5: テスト設計（新機能＋回帰テスト）
2. Part B: Stage 2-3のみ実行（5エージェント）
3. Part C: 影響範囲を重点検証

実行例:
「統合型設計書テンプレートのAI駆動アジャイル開発アプローチで
決済機能を既存ECサイトに追加してください。
決済機能の設計仕様を明確にし、既存の購入フローとの
連携ポイントを設計してください。」

所要時間: 2-3時間
成果物: 変更設計書、追加コード、連携仕様、回帰テスト
```

### ケース3: 緊急バグ修正
```
状況: 本番環境で発生した重大バグ
推奨: 統合型テンプレート・緊急修正モード

手順:
1. Part A: セクション1,4のみ
2. Part B: Stage 3のみ実行（2エージェント）
3. Part C: 簡易検証

実行例:
「統合型設計書テンプレートの緊急修正モードで
ログイン認証エラーを修正してください。
最小限の変更で24時間以内に解決してください。」

所要時間: 1時間
成果物: 修正パッチ、テスト結果、対策書
```

### ケース4: 大規模リファクタリング
```
状況: 技術的負債の解消、パフォーマンス改善
推奨: 統合型テンプレート・段階的改善モード

手順:
1. Part A: セクション1,2,3,5を記載
   - セクション1: リファクタリングの目的と成功基準
   - セクション2: 新アーキテクチャ設計
   - セクション3: 段階的移行計画
   - セクション5: 品質保証とテスト戦略
2. Part B: Stage 2,3を反復実行
3. Part C: 段階ごとに検証

実行例:
「統合型設計書テンプレートを使用して
レガシーコードを段階的にリファクタリングしてください。
改善目標を明確にし、新設計への移行計画を立ててください。」

所要時間: 2-3時間×複数回
成果物: リファクタリング計画、改善コード、性能測定結果
```

## よくある抜け漏れと対策

### 1. 要件の抜け漏れ
```
症状: 実装後に「この機能も必要だった」
原因: ステークホルダーの要求分析不足
対策: 
- ユーザーストーリーマッピング
- 機能要件チェックリスト活用
- プロトタイプによる確認
```

### 2. エラーケースの考慮不足
```
症状: 本番環境でエラー多発
原因: 異常系の検討不足
対策:
- エラーマトリックス作成
- 境界値分析
- 負荷テスト実施
```

### 3. 非機能要件の見落とし
```
症状: パフォーマンス問題、セキュリティ脆弱性
原因: 非機能要件の軽視
対策:
- 定量的な目標設定
- 早期のパフォーマンステスト
- セキュリティレビュー必須化
```

---

## まとめ

### このテンプレートが実現すること
1. **完全性**: 設計書に必要な全要素を網羅
2. **効率性**: エージェント協調で並列作業
3. **品質**: 100点達成まで自動改善
4. **柔軟性**: アジャイル開発に対応
5. **実用性**: ケース別の使い分けが可能

### 成功の鍵
- **段階的適用**: 最初は軽量版から始める
- **継続的改善**: フィードバックを反映
- **チーム共有**: テンプレートを共通言語に
- **自動化推進**: エージェント協調の活用

---

*このテンプレートにより、抜け漏れのない高品質な設計書を効率的に作成できます。*