
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## ⚠️ 最重要：必ず守るべき5原則

### 🔴 原則1: TodoWriteを必ず使用
**3ステップ以上の作業は必ずTodoWriteで管理**

### 🔴 原則2: サブエージェントを必ず使用  
**複雑な処理は必ずTask toolで実行**

### 🔴 原則3: MCPサーバーを必ず使用
**外部連携が可能な場合は必ずMCPを活用**

### 🔴 原則4: ClaudeCodeActionsを必ず使用
**Git操作、PR作成、コードレビューはClaudeCodeActionsで実行**

### 🔴 原則5: Git Worktreesを必ず使用
**並行開発、機能ブランチ管理は必ずGit Worktreesで実行**

## 🚀 重要：開発作業原則

### 5つのツールをフル活用する原則
**すべての開発作業において、以下の5つのツールを必ずフル活用すること：**

1. **📋 TodoWriteツール** - 作業の可視化と進捗管理
2. **🤖 サブエージェント（Task tool）** - 複雑な処理の実行
3. **🔧 MCPサーバー** - 外部システムとの連携
4. **⚡ ClaudeCodeActions** - Git操作とコードレビューの自動化
5. **🌳 Git Worktrees** - 並行開発と機能ブランチ管理

### TodoWriteツール必須使用
**3ステップ以上の作業は必ずTodoWriteで管理すること。**
- 作業開始前にTodoリスト作成
- 各タスク完了時に即座にステータス更新
- ユーザーへの進捗可視化を常に意識

### サブエージェント優先の作業方針
**すべての開発作業において、原則としてサブエージェント（Task tool）を使用すること。**

1. **必須使用ケース**：
   - コード実装・修正作業
   - 複数ファイルの調査・分析
   - リファクタリング作業
   - テスト実装・実行
   - ドキュメント作成・更新
   - デバッグ・問題解決
   - PRD作成・更新作業

2. **サブエージェント活用のメリット**：
   - 並列処理による効率化
   - 専門性の高い処理の実現
   - コンテキスト管理の最適化
   - エラー処理の改善
   - 大規模な変更の安全な実行

3. **実行例**：
   ```
   Task(
     description: "PRD更新作業",
     prompt: "PRD_完全統合版.mdに注釈機能と画像解析機能の詳細仕様を追加。技術仕様、ユースケース、テスト計画を含める",
     subagent_type: "general-purpose"
   )
   ```

4. **直接作業を行う例外ケース**：
   - 単純なファイル読み取り（Read tool）
   - 簡単な状態確認（1-2コマンドのBash実行）
   - ユーザーへの質問・確認
   - 作業結果の報告

## 🤖 利用可能なサブエージェント一覧

### サブエージェント詳細仕様

| エージェント名 | タイプ | 主要スキル | 利用可能ツール | SubAgentsファイルパス | 推奨用途 |
|--------------|-------|------------|--------------|---------------------|---------|
| general-purpose | 汎用 | - 複雑な問題解決<br>- マルチステップタスク<br>- コード実装・リファクタリング<br>- ドキュメント作成 | すべてのツール（*） | システム内蔵<br>（.claude/agents/配下が存在する場合：<br>`~/.claude/agents/general-purpose.md`） | - PRD作成・更新<br>- 大規模な機能実装<br>- 複数ファイルの調査・分析<br>- テスト実装 |
| statusline-setup | 専門 | - Claude Code設定管理<br>- ステータスライン構成 | Read, Edit | システム内蔵<br>（.claude/agents/配下が存在する場合：<br>`~/.claude/agents/statusline-setup.md`） | - Claude Codeのステータスライン設定<br>- 表示カスタマイズ |
| ai-driven-app-architect | システム設計 | - システムアーキテクチャ設計<br>- 技術スタック選定<br>- API設計・データモデリング<br>- 非機能要件分析<br>- インフラ設計 | Read, Write, Grep, Glob, Task, MultiEdit, WebSearch, TodoWrite, ExitPlanMode, WebFetch | `C:\d\PlantUML\.claude\agents\ai-driven-app-architect.md` | - システム全体設計<br>- アーキテクチャ意思決定<br>- 技術検討・評価<br>- 統合設計<br>- スケーラビリティ設計 |
| claude-code-config-expert | 設定専門 | - Claude Code設定・導入<br>- MCP統合設定<br>- IDE統合設定<br>- トラブルシューティング<br>- 日本語対応 | Read, Write, Grep, Glob, Task, MultiEdit, WebSearch, TodoWrite, ExitPlanMode, WebFetch | `C:\d\PlantUML\.claude\agents\claude-code-config-expert.md` | - Claude Code環境構築<br>- MCP設定支援<br>- 設定問題解決<br>- 開発環境最適化<br>- 日本語ユーザー支援 |
| dev-ticket-manager | プロジェクト管理 | - タスク分解・管理<br>- 依存関係分析<br>- アジャイル手法<br>- リソース計画<br>- リスク管理 | Read, Write, Grep, Glob, Task, TodoWrite, ExitPlanMode, WebSearch, MultiEdit, Bash | `C:\d\PlantUML\.claude\agents\dev-ticket-manager.md` | - プロジェクト計画<br>- スプリント管理<br>- タスク調整<br>- 進捗管理<br>- 開発プロセス最適化 |
| docker-dev-env-builder | 開発環境構築 | - Docker・コンテナ設計<br>- マルチサービス構成<br>- CI/CD統合<br>- セキュリティ設定<br>- 日本語対応 | Read, Write, Bash, Grep, Glob, Task, WebSearch, TodoWrite, MultiEdit, WebFetch, Edit | `C:\d\PlantUML\.claude\agents\docker-dev-env-builder.md` | - Docker環境構築<br>- 開発環境標準化<br>- コンテナ最適化<br>- 環境自動化<br>- インフラ設計 |
| mcp-server-setup-expert | MCP統合 | - MCP サーバー設定<br>- ツール選定・統合<br>- 設定最適化<br>- トラブルシューティング<br>- 日本語サポート | Read, Write, Bash, Grep, Glob, WebFetch, Task, WebSearch, TodoWrite, ExitPlanMode | `C:\d\PlantUML\.claude\agents\mcp-server-setup-expert.md` | - MCP環境構築<br>- ツール統合支援<br>- 設定問題解決<br>- 開発効率化<br>- AI統合支援 |
| software-doc-writer | 技術文書作成 | - 技術文書構造化<br>- API仕様書作成<br>- 図表・視覚化<br>- 用語管理<br>- クロスリファレンス管理 | Read, Write, MultiEdit, Grep, Glob, WebSearch, Task, TodoWrite, Bash | `C:\d\PlantUML\.claude\agents\software-doc-writer.md` | - 設計書作成<br>- API仕様書<br>- 技術文書統一<br>- 図表作成<br>- ドキュメント管理 |
| web-debug-specialist | フロントエンド最適化 | - UI/UX実装<br>- ブラウザ互換性<br>- パフォーマンス最適化<br>- デバッグ・トラブルシュート<br>- アクセシビリティ | Read, Write, Grep, Glob, Bash, WebFetch, Task, WebSearch, TodoWrite, ExitPlanMode | `C:\d\PlantUML\.claude\agents\web-debug-specialist.md` | - フロントエンド設計<br>- UI実装・最適化<br>- バグ修正・デバッグ<br>- パフォーマンス改善<br>- レスポンシブ対応 |
| webapp-test-automation | テスト自動化 | - テスト戦略策定<br>- 自動化フレームワーク<br>- 品質指標管理<br>- CI/CD テスト統合<br>- パフォーマンステスト | Read, Write, Grep, Glob, Bash, Task, TodoWrite, WebSearch, ExitPlanMode | `C:\d\PlantUML\.claude\agents\webapp-test-automation.md` | - テスト戦略作成<br>- テスト自動化<br>- 品質管理<br>- CI/CDテスト統合<br>- テストフレームワーク構築 |

### サブエージェント活用の詳細ガイド

#### general-purpose エージェント
**概要**: 最も強力で柔軟な汎用エージェント  
**強み**:
- すべてのツールへのアクセス権限
- 長時間の複雑なタスクを自律的に実行
- エラー時の自動リカバリー機能
- 並列処理による高速実行

**典型的な使用パターン**:
```javascript
// PRD更新の例
Task(
  description: "PRD完全更新",
  prompt: "PRD_完全統合版.mdに新機能の詳細仕様を追加し、関連ドキュメントも同期更新",
  subagent_type: "general-purpose"
)

// 大規模リファクタリングの例
Task(
  description: "コードベース最適化",
  prompt: "全JavaScriptファイルのES6化とモジュール分割を実行",
  subagent_type: "general-purpose"
)
```

#### statusline-setup エージェント
**概要**: Claude Codeのステータスライン設定に特化  
**強み**:
- 設定ファイルの安全な編集
- 構成の妥当性検証
- ユーザー好みの表示設定

### サブエージェント選択フローチャート

```
タスクの評価
    ↓
複雑度は？
    ├─ 高（3つ以上のファイル操作） → general-purpose
    ├─ 中（1-2ファイルの編集） → general-purpose
    └─ 低（設定変更のみ） → 
        └─ Claude Code設定？
            ├─ Yes → statusline-setup
            └─ No → 直接実行

```

### MCPサーバー必須活用
**利用可能なMCPサーバーは必ず活用すること。**

#### 利用可能なMCPサーバー
| MCPサーバー | プレフィックス | 主な用途 |
|------------|---------------|---------|
| **GitHub** | `mcp__github__*` | Issue/PR管理、コード管理 |
| **Playwright** | `mcp__playwright__*` | E2Eテスト、UI自動検証 |
| **Fetch** | `mcp__fetch__*` | Web情報取得 |
| **Context7** | `mcp__context7__*` | ドキュメント参照 |
| **IDE** | `mcp__ide__*` | VS Code連携、診断 |

**注意**: ClaudeCodeActionsはMCPサーバーではなく、Claude Code内蔵の機能のため、MCPプレフィックスは使用しません。

### ClaudeCodeActions必須活用
**Git操作、PR作成、コードレビューは必ずClaudeCodeActionsを活用すること。**

#### ClaudeCodeActionsの概要
ClaudeCodeActionsは、Claude Codeに統合された強力な開発ワークフロー自動化機能です：

**主要機能**:
- **Git操作の自動化**: コミット、プッシュ、ブランチ切り替えの統一化
- **PR作成・管理**: 自動的なプルリクエスト作成とレビュー依頼
- **コードレビュー**: 自動コード品質チェックと改善提案
- **CI/CD連携**: ビルド、テスト、デプロイパイプラインとの統合

#### 必須使用ケース
```javascript
// 新機能開発の完全ワークフロー
1. ClaudeCodeActions.createFeatureBranch("feature/new-annotation-tools")
2. サブエージェントで実装
3. ClaudeCodeActions.commitAndPush("新しい注釈ツール機能を追加")
4. ClaudeCodeActions.createPullRequest({
     title: "注釈ツール機能追加",
     description: "Canvas APIベースの高度な注釈機能を実装"
   })
5. ClaudeCodeActions.performCodeReview()
```

#### 活用メリット
- **標準化されたGitワークフロー**: 一貫性のある開発プロセス
- **自動品質チェック**: コードレビューと品質保証の自動化
- **効率的なコラボレーション**: チームでの開発効率向上
- **トレーサビリティ**: 変更履歴と意思決定プロセスの記録

### Git Worktrees必須活用
**並行開発、機能ブランチ管理は必ずGit Worktreesを活用すること。**

#### Git Worktreesの概要
Git Worktreesは、1つのリポジトリで複数のワーキングディレクトリを管理する強力な機能です：

**基本概念**:
- **複数ワーキングディレクトリ**: 同じリポジトリの異なるブランチを同時に操作
- **独立した作業環境**: 各機能開発を独立した環境で実行
- **効率的なブランチ切り替え**: ファイルの再ビルドなしにブランチ間移動

#### 必須使用ケース
```bash
# 新機能開発用Worktreeの作成
git worktree add ../plantuml-feature-annotation feature/annotation-tools

# バグ修正用Worktreeの作成  
git worktree add ../plantuml-hotfix-rendering hotfix/rendering-bug

# 実験的機能用Worktreeの作成
git worktree add ../plantuml-experimental-ai experimental/ai-integration
```

#### 活用メリット
- **並行開発の効率化**: 複数機能を同時に開発可能
- **コンテキストスイッチの削減**: ブランチ切り替え時のオーバーヘッドを最小化
- **独立したテスト環境**: 各機能のテストを干渉なく実行
- **リスク分散**: 実験的変更の影響を他の作業から分離

#### 実践的な使用例
```bash
# プロジェクト構造例
C:\d\PlantUML\                           # メインワーキングディレクトリ (main)
C:\d\PlantUML-feature-annotation\        # 注釈機能開発
C:\d\PlantUML-hotfix-rendering\          # レンダリング修正
C:\d\PlantUML-experimental-ai\           # AI機能実験

# 各ディレクトリで独立した開発
cd C:\d\PlantUML-feature-annotation
npm install  # 独立した依存関係管理
docker-compose up  # 独立したコンテナ環境
```

### 作業フロー（5ツール統合）
1. ユーザーからのリクエスト受信
2. **Git Worktreesで新しいワーキングディレクトリ作成**
3. **TodoWriteでタスクリスト作成**
4. **サブエージェントで実装・調査を実行**
5. **MCPサーバーで外部連携**
6. **ClaudeCodeActionsでGit操作・PR作成**
7. **TodoWriteでステータス更新**
8. 結果を確認・検証
9. ユーザーに報告

## プロジェクト概要

### 基本情報
- **プロジェクト名**: 日本語→PlantUML変換アプリ
- **タイプ**: Webアプリケーション（SPA）
- **アーキテクチャ**: Docker化されたNode.js/Express + フロントエンドSPA
- **ローカルパス**: `C:\d\PlantUML`

### 現在のステータス
- **フェーズ**: PRD（製品要求定義）作成フェーズ
- **主要PRD**: `PRD_完全統合版.md`
- **実装済み機能**: 
  - 基本的な日本語→PlantUML変換
  - Kroki APIを使用したレンダリング
  - 注釈機能（Canvas APIベース）
  - 画像解析機能（OCR + パターン認識）

## プロジェクト構造

```
C:\d\PlantUML/
├── CLAUDE.md                              # このファイル
├── PRD_完全統合版.md                      # 製品要求定義書（メイン）
├── PRD_日本語からPlantUMLを簡単生成するSPA_企画書.md
├── PRD_日本語からPlantUMLを簡単生成するSPA_企画書_改訂版.md
├── PRD_日本語からPlantUMLを簡単生成するSPA_企画書_読みやすい版.md
├── PRD_機能要件詳細.md
├── PlantUML_ガントチャート_制限事項Ver1.0_20250601.md
├── PlantUML_ガントチャート_制限事項Ver1.1_20250601.md
├── PlantUMLレンダリング段階的アプローチ.md
├── Flow.io連携機能仕様.md
├── draw.io_XML形式実装ガイド.md
├── draw.io_XML最適化実装ガイド.md
├── チャット履歴_*.md                      # 開発履歴
└── jp2plantuml/                           # アプリケーション本体
    ├── Dockerfile
    ├── docker-compose.yml
    ├── package.json
    ├── package-lock.json
    ├── server.js                          # Express サーバー
    ├── public/                            # フロントエンド
    │   ├── index.html                    # メインHTML
    │   ├── main.js                       # メインロジック
    │   ├── styles.css                    # スタイルシート
    │   ├── annotation.js                 # 注釈機能
    │   └── image-analyzer.js             # 画像解析機能
    └── src/                               # バックエンド処理
        ├── convert.js                     # 変換エンジン
        └── parsers/                       # 図種別パーサー
            ├── activity.js
            ├── class.js
            ├── gantt.js
            ├── sequence.js
            ├── state.js
            └── usecase.js
```

## システムアーキテクチャ

### 技術スタック
- **バックエンド**: Node.js + Express
- **フロントエンド**: Vanilla JavaScript (SPA)
- **コンテナ**: Docker + Docker Compose
- **レンダリング**: Kroki API
- **OCR**: Tesseract.js
- **画像処理**: Canvas API

### 主要コンポーネント

#### サーバーサイド（server.js）
```javascript
// APIエンドポイント
POST /api/convert       // 日本語→PlantUML変換
POST /api/render        // PlantUML→SVGレンダリング
POST /api/analyze-image // 画像解析
```

#### クライアントサイド
```javascript
// グローバルオブジェクト
window.AnnotationTool   // 注釈機能管理
window.ImageAnalyzer    // 画像解析機能
window.annotationTool   // 注釈ツールインスタンス
```

## 開発コマンド

### Docker環境での起動
```bash
# ビルドと起動
cd jp2plantuml
docker-compose build
docker-compose up -d

# ログ確認
docker-compose logs -f

# 停止
docker-compose down
```

### ローカル環境での起動
```bash
# 依存関係インストール
cd jp2plantuml
npm install

# サーバー起動
npm start
# または開発モード
npm run dev
```

アクセス: http://localhost:3001

### パッケージ管理
```bash
# 新しいパッケージの追加
npm install [package-name]

# Docker環境の場合は再ビルド必要
docker-compose build
```

## 機能仕様

### 1. 日本語→PlantUML変換
- **入力**: 自然な日本語テキスト
- **処理**: 形態素解析 + パターンマッチング
- **出力**: PlantUMLコード

### 2. 図の種類
- ガントチャート
- シーケンス図
- クラス図
- アクティビティ図
- 状態遷移図
- ユースケース図

### 3. 注釈機能
- Canvas APIベースの描画レイヤー
- ツール: ペン、矢印、テキスト、消しゴム
- 保存/読込機能（JSON形式）
- 画像エクスポート（PNG）

### 4. 画像解析機能
- OCR（Tesseract.js）による文字認識
- パターン認識による図種判定
- 自動PlantUMLコード生成

## PRD作成ガイドライン

### PRDファイルの更新ルール
1. **メインPRD**: `PRD_完全統合版.md`を最優先で更新
2. **機能追加時**: 以下のセクションを更新
   - 機能要件
   - 技術仕様
   - ユースケース
3. **フォーマット**: Markdownで記述、表形式を活用

### PRD記載項目
- 機能概要
- ユーザーストーリー
- 技術仕様
- UI/UXデザイン
- 非機能要件
- テスト計画

## 作業時の注意事項

### 🎯 最重要：サブエージェント優先原則
**すべての実装・調査作業は、まずサブエージェント（Task tool）での実行を検討すること。**
直接作業は最小限に留め、複雑な処理は必ずサブエージェントに委譲する。

### サブエージェント実行ガイドライン

#### 複雑なタスクの分割
大規模な作業は複数のサブエージェントタスクに分割：
- 調査フェーズ → 実装フェーズ → テストフェーズ
- 各フェーズを独立したサブエージェントで実行

#### 並列実行の推奨
独立したタスクは並列実行で効率化：
```javascript
// 複数のサブエージェントを同時実行
[
  Task(description: "コード分析", ...),
  Task(description: "テスト作成", ...),
  Task(description: "ドキュメント更新", ...)
]
```

#### エラーハンドリング
サブエージェントのエラーは適切に処理：
- エラー時は代替アプローチを検討
- 必要に応じて再実行
- ユーザーへの明確な報告

### コード実装前の確認
1. **PRD確認**: 機能がPRDに定義されているか確認
2. **影響範囲**: 既存機能への影響を評価
3. **テスト**: 実装後のテスト計画を事前に策定

### Git操作
```bash
# 変更をコミット
git add .
git commit -m "機能: [機能名] - [変更内容]"

# 例
git commit -m "機能: 注釈機能 - Canvas APIベースの描画機能を追加"
```

### デバッグ
```javascript
// ブラウザコンソールでのデバッグ
console.log('変換結果:', result);

// エラーハンドリング
try {
  // 処理
} catch (error) {
  console.error('エラー:', error);
}
```

## よくある問題と対処

### Docker関連
```bash
# ポート競合エラー
# 解決: docker-compose.ymlのポート番号を変更

# ビルドエラー
# 解決: キャッシュクリア
docker-compose build --no-cache
```

### 変換エラー
```javascript
// 日本語パースエラー
// 解決: 入力テキストの形式を確認

// レンダリングエラー
// 解決: PlantUML構文を検証
```

## 5ツール統合活用例

### 機能実装の完全ワークフロー
```javascript
// 1. Git Worktreeで新環境作成
git worktree add ../plantuml-feature-enhanced-annotation feature/enhanced-annotation

// 2. TodoWriteでタスク管理開始
TodoWrite([
  {id: "1", content: "要件確認", status: "in_progress"},
  {id: "2", content: "実装", status: "pending"},
  {id: "3", content: "テスト", status: "pending"},
  {id: "4", content: "PR作成・レビュー", status: "pending"},
  {id: "5", content: "ドキュメント更新", status: "pending"}
])

// 3. サブエージェントで実装
Task(
  description: "機能実装",
  prompt: "注釈機能を完全実装",
  subagent_type: "general-purpose"
)

// 4. MCPでテスト実行
mcp__playwright__browser_navigate({url: "http://localhost:3001"})
mcp__playwright__browser_snapshot()

// 5. ClaudeCodeActionsでPR作成
ClaudeCodeActions.commitAndPush("注釈機能強化: Canvas APIベースの高度な描画ツールを追加")
ClaudeCodeActions.createPullRequest({
  title: "注釈機能の大幅強化",
  description: "高精度ペンツール、図形描画、レイヤー管理機能を追加"
})

// 6. TodoWrite更新
TodoWrite([
  {id: "1", content: "要件確認", status: "completed"},
  {id: "2", content: "実装", status: "completed"},
  {id: "3", content: "テスト", status: "completed"},
  {id: "4", content: "PR作成・レビュー", status: "completed"},
  {id: "5", content: "ドキュメント更新", status: "in_progress"}
])
```

## サブエージェント活用例

### PRD作成・更新
```javascript
Task(
  description: "PRD完全統合版更新",
  prompt: `
    PRD_完全統合版.mdに以下の内容を追加：
    1. 注釈機能の詳細仕様
    2. 画像解析機能の詳細仕様
    3. 各機能のユースケース
    4. テスト計画
    5. API仕様
  `,
  subagent_type: "general-purpose"
)
```

### 複数ファイル調査
```javascript
Task(
  description: "依存関係調査",
  prompt: `
    jp2plantumlディレクトリ内のすべてのファイルを調査し、
    モジュール間の依存関係を分析。
    結果を依存関係図として出力。
  `,
  subagent_type: "general-purpose"
)
```

### リファクタリング作業
```javascript
Task(
  description: "コード最適化",
  prompt: `
    main.jsのコードをリファクタリング：
    1. 重複コードの削除
    2. 関数の分割と整理
    3. エラーハンドリングの改善
    4. コメントの追加
  `,
  subagent_type: "general-purpose"
)
```

### テスト実装
```javascript
Task(
  description: "E2Eテスト作成",
  prompt: `
    Playwright MCPを使用してE2Eテストを作成：
    1. 基本的な変換機能のテスト
    2. 注釈機能のテスト
    3. 画像アップロードのテスト
    4. エラーケースのテスト
  `,
  subagent_type: "general-purpose"
)
```

## デバッグレポート作成

### 作成ルール
- **1事案1ファイル**: 関連する問題は1つのレポートに統合
- **ファイル名**: `debug_report_YYYYMMDD_HHMM_[問題の概要].md`
- **保存場所**: プロジェクトルート

### レポート内容
```markdown
# デバッグレポート

## 問題の概要
[問題の説明]

## 再現手順
1. [手順1]
2. [手順2]

## 期待される動作
[期待される動作]

## 実際の動作
[実際の動作]

## 解決策
[実施した解決策]

## 学習事項
[今後のための学習事項]
```

## 🔧 MCP（Model Control Protocol）サーバー活用ガイド

### 利用可能なMCPサーバー一覧

#### 1. GitHub操作 (`mcp__github__*`)
**プレフィックス**: `mcp__github__`  
**目的**: GitHub リポジトリの包括的操作

**主要機能**:
- `create_repository` - 新規リポジトリ作成
- `fork_repository` - リポジトリのフォーク
- `create_branch` - ブランチ作成
- `create_or_update_file` - ファイル作成・更新
- `push_files` - 複数ファイルの一括プッシュ
- `create_pull_request` - プルリクエスト作成
- `merge_pull_request` - プルリクエストのマージ
- `create_issue` - Issue作成
- `search_repositories` - リポジトリ検索
- `search_code` - コード検索
- `get_file_contents` - ファイル内容取得

**使用例**:
```javascript
// 新機能ブランチ作成 → コード実装 → PR作成の一連の流れ
mcp__github__create_branch(owner: "user", repo: "project", branch: "feature/new-function")
mcp__github__create_or_update_file(...)  // コード実装
mcp__github__create_pull_request(...)    // PR作成
```

**適用場面**:
- CI/CDパイプライン構築
- 自動デプロイ設定
- コードレビュープロセス管理
- バージョン管理戦略

#### 2. ブラウザ自動操作 (`mcp__playwright__*`)
**プレフィックス**: `mcp__playwright__`  
**目的**: E2Eテスト、ブラウザ操作自動化

**主要機能**:
- `browser_navigate` - ページ遷移
- `browser_click` - 要素クリック
- `browser_type` - テキスト入力
- `browser_snapshot` - ページ状態キャプチャ
- `browser_take_screenshot` - スクリーンショット取得
- `browser_evaluate` - JavaScript実行
- `browser_console_messages` - コンソールメッセージ取得
- `browser_wait_for` - 要素待機
- `browser_select_option` - ドロップダウン選択

**使用例**:
```javascript
// PlantUML変換アプリの自動テスト
mcp__playwright__browser_navigate(url: "http://localhost:3001")
mcp__playwright__browser_type(element: "テキスト入力欄", text: "シーケンス図のテストケース")
mcp__playwright__browser_click(element: "変換ボタン")
mcp__playwright__browser_wait_for(text: "PlantUML")
mcp__playwright__browser_console_messages()  // エラーチェック
```

**適用場面**:
- Webアプリの動作検証（必須）
- リグレッションテスト
- パフォーマンステスト
- ユーザビリティテスト

#### 3. Web情報取得 (`mcp__fetch__*`)
**プレフィックス**: `mcp__fetch__`  
**目的**: Web上の情報取得、APIアクセス

**主要機能**:
- `fetch_url` - URL からのコンテンツ取得
- `fetch_youtube_transcript` - YouTube動画の字幕取得

**使用例**:
```javascript
// PlantUML公式ドキュメントから最新情報取得
mcp__fetch__fetch_url(
  url: "https://plantuml.com/ja/sequence-diagram",
  max_length: 5000
)

// 技術記事の情報収集
mcp__fetch__fetch_url(
  url: "https://example.com/plantuml-best-practices",
  raw: false  // Markdown形式で取得
)
```

**適用場面**:
- 技術情報の調査
- API仕様の確認
- 競合分析
- 最新技術トレンドの把握

#### 4. ライブラリドキュメント参照 (`mcp__context7__*`)
**プレフィックス**: `mcp__context7__`  
**目的**: 最新のライブラリドキュメント参照

**主要機能**:
- `resolve_library_id` - ライブラリID解決
- `get_library_docs` - ドキュメント取得

**使用例**:
```javascript
// Express.jsの最新ドキュメント取得
mcp__context7__resolve_library_id(libraryName: "express")
// 結果: "/expressjs/express"
mcp__context7__get_library_docs(
  context7CompatibleLibraryID: "/expressjs/express",
  topic: "routing",
  tokens: 10000
)
```

**適用場面**:
- ライブラリの使用方法確認
- API仕様の詳細調査
- ベストプラクティス学習
- バージョン間の差分確認

#### 5. VS Code連携 (`mcp__ide__*`)
**プレフィックス**: `mcp__ide__`  
**目的**: IDE連携、診断情報取得

**主要機能**:
- `getDiagnostics` - 診断情報（エラー、警告）取得
- `executeCode` - Jupyterカーネルでのコード実行

**使用例**:
```javascript
// プロジェクト全体の診断情報取得
mcp__ide__getDiagnostics()  // 全ファイル

// 特定ファイルの診断情報取得
mcp__ide__getDiagnostics(uri: "file:///path/to/main.js")
```

**適用場面**:
- コード品質チェック
- エラー・警告の一括確認
- リファクタリング前の状態確認
- 依存関係の問題特定

### 🎯 MCP活用の基本原則

#### 1. MCP優先の原則
**MCPサーバーが利用できる場合は、必ずMCPを優先して使用する**

```javascript
// ❌ 避けるべき：直接的なBashコマンド実行
Bash(command: "curl -X GET https://api.github.com/repos/user/repo")

// ✅ 推奨：MCPサーバー使用
mcp__github__get_file_contents(owner: "user", repo: "repo", path: "README.md")
```

#### 2. 機能の組み合わせ活用
**複数のMCPサーバーを組み合わせて、より強力な機能を実現**

```javascript
// Webアプリ開発の完全ワークフロー例
// 1. GitHub でコード実装
mcp__github__create_branch(...)
mcp__github__push_files(...)

// 2. Playwright でテスト実行
mcp__playwright__browser_navigate(...)
mcp__playwright__browser_click(...)

// 3. Context7 で技術調査
mcp__context7__get_library_docs(...)

// 4. IDE連携で品質チェック
mcp__ide__getDiagnostics()
```

#### 3. エラーハンドリングと代替手段
**MCPでエラーが発生した場合の対応策を事前に準備**

```javascript
// プライマリ：MCP使用
try {
  mcp__github__create_pull_request(...)
} catch (error) {
  // フォールバック：他の手段を検討
  console.log("MCP実行失敗、代替手段を検討")
}
```

## 🤖 サブエージェント詳細ガイド

### サブエージェントの種類と特徴

#### 1. general-purpose エージェント
**概要**: 汎用性に特化した標準エージェント  
**適用範囲**: ほぼ全ての開発タスクに対応

**強み**:
- 柔軟な問題解決能力
- 複数の技術領域を横断した処理
- 長期的なコンテキスト維持
- エラー時の自動復旧機能

**推奨使用ケース**:
- PRD作成・更新
- コード実装・リファクタリング
- 複数ファイルの調査・分析
- テスト作成・実行
- ドキュメント生成

### サブエージェント選択基準

#### タスクの複雑度による判断

**高複雑度（必須使用）**:
- 複数ファイルの同期的変更
- アーキテクチャレベルの設計変更
- 包括的なテスト実装
- 大規模なリファクタリング

**中複雑度（推奨使用）**:
- 新機能の実装
- APIエンドポイントの追加
- UI/UXの改善
- パフォーマンス最適化

**低複雑度（直接実行可）**:
- 単一ファイルの読み取り
- 簡単な設定変更
- ステータス確認コマンド

#### 処理時間による判断

**長時間処理（サブエージェント推奨）**:
- 5分以上の処理が予想される作業
- 多数のファイル操作
- 外部APIとの複雑な連携

**短時間処理（直接実行可）**:
- 1-2分以内で完了する作業
- 単純な情報取得
- 状態確認

### サブエージェント実行パターン

#### 1. 段階的実行パターン
```javascript
// Phase 1: 調査・分析
Task(
  description: "要件分析フェーズ",
  prompt: "現在の実装状況を調査し、新機能の実装方針を策定",
  subagent_type: "general-purpose"
)

// Phase 2: 実装
Task(
  description: "実装フェーズ",
  prompt: "Phase 1の結果を基に、具体的なコード実装を実行",
  subagent_type: "general-purpose"
)

// Phase 3: テスト・検証
Task(
  description: "テストフェーズ",
  prompt: "Playwright MCPを使用した包括的なテスト実行",
  subagent_type: "general-purpose"
)
```

#### 2. 並列実行パターン
```javascript
// 独立したタスクを並列実行
[
  Task(description: "フロントエンド修正", ...),
  Task(description: "バックエンドAPI作成", ...),
  Task(description: "テストケース作成", ...),
  Task(description: "ドキュメント更新", ...)
]
```

#### 3. 依存関係を持つ実行パターン
```javascript
// Task A の結果を Task B で使用
const resultA = Task(description: "基盤調査", ...)
const resultB = Task(
  description: "resultAを基にした実装",
  prompt: `${resultA}の結果を踏まえて実装を進める`,
  ...
)
```

### MCPとサブエージェントの連携

#### 最適な組み合わせパターン

**Webアプリ開発ワークフロー**:
```javascript
Task(
  description: "完全なWebアプリ開発サイクル",
  prompt: `
    以下の順序で作業を実行：
    1. mcp__github__* でコード管理
    2. 実装・修正作業
    3. mcp__playwright__* でE2Eテスト
    4. mcp__ide__* で品質チェック
    5. 結果報告とドキュメント更新
  `,
  subagent_type: "general-purpose"
)
```

**技術調査ワークフロー**:
```javascript
Task(
  description: "技術調査と実装",
  prompt: `
    1. mcp__context7__* で最新ドキュメント調査
    2. mcp__fetch__* で関連情報収集
    3. 調査結果の整理とまとめ
    4. 実装への適用方針策定
  `,
  subagent_type: "general-purpose"
)
```

## 💡 MCP活用のベストプラクティス

### 1. タスク設計の原則
- **明確な目標設定**: 各MCPの目的を明確にする
- **適切な粒度**: 過度に細分化しない、過度に統合しない
- **エラー対応**: 失敗時の代替手段を準備

### 2. パフォーマンス最適化
- **キャッシュ活用**: 同じ情報の重複取得を避ける
- **並列実行**: 独立したタスクは同時実行
- **リソース管理**: 不要なブラウザセッションは適時クローズ

### 3. セキュリティ考慮事項
- **認証情報**: 必要最小限の権限で実行
- **データ保護**: 機密情報の適切な取り扱い
- **アクセス制御**: 不必要なリソースアクセスを避ける

## ⚡ ClaudeCodeActions実践ガイド

### 基本的なワークフロー

#### 1. 新機能開発の標準フロー
```javascript
// Step 1: 機能ブランチの作成
ClaudeCodeActions.createBranch("feature/advanced-image-analysis")

// Step 2: 実装作業（サブエージェント使用）
Task(description: "画像解析機能の実装", ...)

// Step 3: 変更のコミット
ClaudeCodeActions.commitChanges({
  message: "画像解析: OCRと図表認識機能を追加",
  files: ["public/image-analyzer.js", "server.js", "src/analyzers/"]
})

// Step 4: プルリクエストの作成
ClaudeCodeActions.createPullRequest({
  title: "高度な画像解析機能の追加",
  description: `
    ## 概要
    OCRとパターン認識を組み合わせた高精度な画像解析機能を実装
    
    ## 変更内容
    - Tesseract.jsによるOCR機能強化
    - 図表パターン認識アルゴリズムの追加
    - リアルタイム解析プレビュー機能
    
    ## テスト
    - [ ] OCR精度テスト
    - [ ] パターン認識テスト
    - [ ] パフォーマンステスト
  `,
  assignees: ["maintainer"],
  labels: ["enhancement", "image-processing"]
})
```

#### 2. バグ修正の迅速フロー
```javascript
// Step 1: ホットフィックスブランチ作成
ClaudeCodeActions.createHotfixBranch("hotfix/rendering-performance-issue")

// Step 2: 修正作業
// ...実装...

// Step 3: 緊急修正のコミット・デプロイ
ClaudeCodeActions.commitAndDeploy({
  message: "修正: レンダリングパフォーマンスの大幅改善",
  deployTarget: "production",
  runTests: true
})
```

### コードレビューの自動化

#### 自動品質チェック
```javascript
// コード品質の包括的チェック
const reviewResult = ClaudeCodeActions.performCodeReview({
  checks: [
    "security",      // セキュリティ脆弱性検査
    "performance",   // パフォーマンス分析
    "maintainability", // 保守性評価
    "testCoverage",  // テストカバレッジ確認
    "documentation"  // ドキュメント充実度
  ],
  standards: "enterprise" // エンタープライズレベルの品質基準
})

// 結果に基づく自動改善提案
if (reviewResult.issues.length > 0) {
  ClaudeCodeActions.suggestImprovements(reviewResult.issues)
}
```

## 🌳 Git Worktrees実践ガイド

### 並行開発のベストプラクティス

#### 1. 機能別Worktreesの管理
```bash
# 現在のWorktree状況確認
git worktree list

# 結果例:
# C:\d\PlantUML                    [main]
# C:\d\PlantUML-feature-annotation [feature/annotation-v2]
# C:\d\PlantUML-hotfix-rendering   [hotfix/svg-display-bug]
# C:\d\PlantUML-experimental-ai    [experimental/ai-assisted-generation]

# 新しいWorktreeの追加
git worktree add ../PlantUML-feature-collaboration feature/real-time-collaboration

# 不要なWorktreeの削除
git worktree remove ../PlantUML-experimental-ai
```

#### 2. 開発環境の独立管理
```bash
# 各Worktreeで独立した開発環境構築

# メイン環境（安定版）
cd C:\d\PlantUML
docker-compose -f docker-compose.prod.yml up -d  # ポート3001

# 機能開発環境
cd C:\d\PlantUML-feature-annotation
docker-compose -f docker-compose.dev.yml up -d   # ポート3002

# 実験環境
cd C:\d\PlantUML-experimental-ai
docker-compose -f docker-compose.experimental.yml up -d  # ポート3003
```

#### 3. テスト環境の分離
```javascript
// 各Worktreeで独立したテスト実行
// メイン環境でのE2Eテスト
mcp__playwright__browser_navigate(url: "http://localhost:3001")

// 機能開発環境でのテスト
mcp__playwright__browser_navigate(url: "http://localhost:3002")

// A/Bテストの実装
const testResults = {
  mainBranch: await testMainFeatures("http://localhost:3001"),
  featureBranch: await testMainFeatures("http://localhost:3002")
}
```

### Worktreesとサブエージェントの連携

#### 複数環境での並列開発
```javascript
// 複数のサブエージェントで並行作業
const parallelTasks = [
  Task({
    description: "メイン環境でのバグ修正",
    prompt: "C:\\d\\PlantUMLでレンダリングバグを修正",
    workingDirectory: "C:\\d\\PlantUML"
  }),
  
  Task({
    description: "機能開発環境での新機能実装",
    prompt: "C:\\d\\PlantUML-feature-annotationで注釈機能を実装",
    workingDirectory: "C:\\d\\PlantUML-feature-annotation"
  }),
  
  Task({
    description: "実験環境でのAI機能プロトタイプ",
    prompt: "C:\\d\\PlantUML-experimental-aiでAI支援機能を実装",
    workingDirectory: "C:\\d\\PlantUML-experimental-ai"
  })
]

// 並列実行で効率的な開発
const results = await Promise.all(parallelTasks)
```

### Worktreesの高度な活用パターン

#### 1. リリースブランチ管理
```bash
# リリース準備用Worktree
git worktree add ../PlantUML-release-v2.0 release/v2.0

# リリース候補の検証環境
cd ../PlantUML-release-v2.0
npm run build:production
docker-compose -f docker-compose.release.yml up -d
```

#### 2. 長期機能開発の管理
```bash
# 長期機能開発用のWorktree
git worktree add ../PlantUML-epic-enterprise enterprise/advanced-features

# 定期的な統合テスト
cd ../PlantUML-epic-enterprise
git merge main  # 定期的なメインブランチとの統合
npm test        # 統合テストの実行
```

#### 3. 顧客デモ環境の独立管理
```bash
# 顧客デモ専用環境
git worktree add ../PlantUML-demo-client-A demo/client-a-customization
git worktree add ../PlantUML-demo-client-B demo/client-b-integration

# 各デモ環境で独立した設定とカスタマイゼーション
```

### 🔄 5ツール統合の完全ワークフロー例

#### 大型機能開発プロジェクト
```javascript
// Phase 1: プロジェクト準備
git worktree add ../PlantUML-epic-ai-integration epic/ai-integration

TodoWrite([
  {id: "setup", content: "Git Worktree環境セットアップ", status: "completed"},
  {id: "research", content: "AI統合技術の調査", status: "pending"},
  {id: "architecture", content: "システムアーキテクチャ設計", status: "pending"},
  {id: "implementation", content: "AI機能実装", status: "pending"},
  {id: "integration", content: "既存システムとの統合", status: "pending"},
  {id: "testing", content: "包括的テスト実行", status: "pending"},
  {id: "review", content: "コードレビューとPR作成", status: "pending"}
])

// Phase 2: 調査フェーズ（サブエージェント活用）
Task({
  description: "AI統合技術調査",
  prompt: `
    以下の観点でAI統合技術を調査：
    1. mcp__context7__*で最新AI技術情報収集
    2. mcp__fetch__*で競合分析
    3. 技術選定とアーキテクチャ提案作成
  `,
  subagent_type: "general-purpose"
})

// Phase 3: 実装フェーズ（MCP + サブエージェント）
Task({
  description: "AI機能実装",
  prompt: `
    AI統合機能を実装：
    1. フロントエンド: AIアシスタント機能
    2. バックエンド: AI API統合
    3. mcp__playwright__*で動作確認
  `,
  workingDirectory: "C:\\d\\PlantUML-epic-ai-integration"
})

// Phase 4: 統合・テスト（MCP活用）
mcp__playwright__browser_navigate(url: "http://localhost:3004")
mcp__playwright__browser_type(element: "AI入力フィールド", text: "複雑なシーケンス図を生成して")

// Phase 5: コードレビュー・PR（ClaudeCodeActions）
ClaudeCodeActions.performCodeReview({
  scope: "epic/ai-integration",
  includeSecurityScan: true,
  includePerformanceAnalysis: true
})

ClaudeCodeActions.createPullRequest({
  title: "🤖 AI統合機能の追加 - 自動図生成とインテリジェント支援",
  description: `
    ## 🎯 概要
    自然言語からのPlantUML自動生成とAI支援機能を実装
    
    ## ✨ 新機能
    - 🧠 自然言語からの図表自動生成
    - 🤖 インテリジェントな図表改善提案
    - 📊 コンテキスト認識による最適化
    
    ## 🔧 技術実装
    - OpenAI GPT-4統合
    - リアルタイム図表解析
    - 機械学習ベースの図表最適化
  `,
  milestone: "v2.0-AI-Integration"
})

// Phase 6: 最終確認（TodoWrite更新）
TodoWrite([
  {id: "setup", content: "Git Worktree環境セットアップ", status: "completed"},
  {id: "research", content: "AI統合技術の調査", status: "completed"},
  {id: "architecture", content: "システムアーキテクチャ設計", status: "completed"},
  {id: "implementation", content: "AI機能実装", status: "completed"},
  {id: "integration", content: "既存システムとの統合", status: "completed"},
  {id: "testing", content: "包括的テスト実行", status: "completed"},
  {id: "review", content: "コードレビューとPR作成", status: "completed"}
])
```

この統合ワークフローにより、5つのツールの力を最大限に活用した効率的で品質の高い開発が実現できます。

## 📋 TodoWriteツール活用ガイド

### TodoWriteツールの概要と重要性

#### なぜTodoWriteが重要なのか
TodoWriteツールは、Claude Codeでの開発作業において**作業の可視化・進捗管理・品質担保**を実現する中核ツールです：

1. **ユーザーへの進捗可視化**
   - 現在何をしているかをリアルタイムで把握可能
   - 完了したタスクと残りのタスクが明確
   - 作業全体のボリュームと進捗率が見える

2. **プロジェクト管理における役割**
   - 複雑な作業の構造化と整理
   - 依存関係や優先度の明確化
   - 作業漏れの防止とミス削減

3. **品質担保**
   - 各段階での確認ポイントを設定
   - 作業完了の定義を明確化
   - バックトラッキングによる問題解決

### 🎯 TodoWrite必須使用ケース

以下のケースでは、**必ずTodoWriteツールを使用**してタスクを管理してください：

#### 1. 複数ステップの作業（3ステップ以上）
```javascript
// 例：新機能実装
TodoWrite([
  {id: "1", content: "要件分析と技術調査", status: "pending"},
  {id: "2", content: "アーキテクチャ設計", status: "pending"},
  {id: "3", content: "コード実装（フロントエンド）", status: "pending"},
  {id: "4", content: "コード実装（バックエンド）", status: "pending"},
  {id: "5", content: "テスト作成・実行", status: "pending"},
  {id: "6", content: "ドキュメント更新", status: "pending"}
])
```

#### 2. 長時間の処理（5分以上）
- 大規模リファクタリング
- 包括的テスト実装
- 複数ファイルの一括修正
- 詳細なコードベース調査

#### 3. デバッグ作業
```javascript
// デバッグワークフロー例
TodoWrite([
  {id: "1", content: "問題の再現と現象確認", status: "in_progress"},
  {id: "2", content: "ログとエラー情報の収集", status: "pending"},
  {id: "3", content: "原因の特定と仮説立案", status: "pending"},
  {id: "4", content: "修正案の実装", status: "pending"},
  {id: "5", content: "修正内容のテスト", status: "pending"},
  {id: "6", content: "デバッグレポート作成", status: "pending"}
])
```

#### 4. PRD作成・更新作業
```javascript
// PRD更新ワークフロー
TodoWrite([
  {id: "1", content: "既存PRDの内容確認", status: "pending"},
  {id: "2", content: "追加機能の要件定義", status: "pending"},
  {id: "3", content: "技術仕様の詳細化", status: "pending"},
  {id: "4", content: "ユースケースの作成", status: "pending"},
  {id: "5", content: "テスト計画の策定", status: "pending"},
  {id: "6", content: "PRDファイルの更新", status: "pending"},
  {id: "7", content: "関連ドキュメントの同期", status: "pending"}
])
```

#### 5. リファクタリング作業
- コードの再構造化
- パフォーマンス最適化
- アーキテクチャ改善
- 依存関係の整理

#### 6. テスト実装
- E2Eテストスイートの作成
- ユニットテストの網羅的実装
- パフォーマンステストの設計
- セキュリティテストの実行

### 🔄 TodoWriteの効果的な使い方

#### 1. タスクの適切な粒度設定

**良い例（適切な粒度）**:
```javascript
TodoWrite([
  {id: "1", content: "annotation.jsファイルの読み込みと現状分析", status: "pending"},
  {id: "2", content: "Canvas APIを使用したペンツール機能の実装", status: "pending"},
  {id: "3", content: "矢印描画機能の追加", status: "pending"},
  {id: "4", content: "テキスト入力機能の実装", status: "pending"},
  {id: "5", content: "消しゴム機能の実装", status: "pending"},
  {id: "6", content: "統合テストの実行", status: "pending"}
])
```

**悪い例（粒度が粗すぎ）**:
```javascript
TodoWrite([
  {id: "1", content: "注釈機能全体の実装", status: "pending"}, // 粗すぎ
  {id: "2", content: "テストの実行", status: "pending"}        // 粗すぎ
])
```

**悪い例（粒度が細かすぎ）**:
```javascript
TodoWrite([
  {id: "1", content: "annotation.jsファイルを開く", status: "pending"},      // 細かすぎ
  {id: "2", content: "1行目を読む", status: "pending"},                    // 細かすぎ
  {id: "3", content: "console.logを追加", status: "pending"}               // 細かすぎ
])
```

#### 2. ステータス管理の原則

**ステータスの定義**:
- `pending`: タスク未開始（初期状態）
- `in_progress`: 現在作業中（**同時に1つのタスクのみ**）
- `completed`: タスク完了

**重要な管理原則**:
1. **1つずつin_progressにする**: 同時に複数のタスクをin_progressにしない
2. **リアルタイム更新**: 作業開始時は即座にin_progressに変更
3. **即座の完了更新**: タスク完了時は即座にcompletedに変更
4. **完了の厳格な定義**: テストが通らない、エラーがある場合は完了にしない

#### 3. リアルタイム更新の重要性

**作業開始時**:
```javascript
// 作業開始前に必ずステータス更新
TodoWrite([
  {id: "1", content: "PRD分析", status: "completed"},
  {id: "2", content: "技術仕様作成", status: "in_progress"}, // 開始時に更新
  {id: "3", content: "実装", status: "pending"}
])
```

**作業完了時**:
```javascript
// 作業完了後に即座にステータス更新
TodoWrite([
  {id: "1", content: "PRD分析", status: "completed"},
  {id: "2", content: "技術仕様作成", status: "completed"}, // 完了時に更新
  {id: "3", content: "実装", status: "in_progress"}       // 次のタスク開始
])
```

### 🤖 TodoWriteとサブエージェント/MCPの連携

#### 1. サブエージェント実行前後のTodo更新

**実行前**:
```javascript
// サブエージェント実行前にタスクをin_progressに
TodoWrite([
  {id: "3", content: "サブエージェントによる複雑な実装タスク", status: "in_progress"}
])

// サブエージェント実行
Task(
  description: "複雑な実装作業",
  prompt: "詳細な実装指示...",
  subagent_type: "general-purpose"
)
```

**実行後**:
```javascript
// サブエージェント完了後にステータス更新
TodoWrite([
  {id: "3", content: "サブエージェントによる複雑な実装タスク", status: "completed"},
  {id: "4", content: "実装結果の検証", status: "in_progress"}
])
```

#### 2. MCP操作時のTodo管理

**Playwright MCP使用例**:
```javascript
TodoWrite([
  {id: "5", content: "Playwright MCPによる自動テスト実行", status: "in_progress"}
])

// MCP実行
mcp__playwright__browser_navigate(url: "http://localhost:3001")
mcp__playwright__browser_type(...)
mcp__playwright__browser_click(...)

// 完了後更新
TodoWrite([
  {id: "5", content: "Playwright MCPによる自動テスト実行", status: "completed"},
  {id: "6", content: "テスト結果の分析", status: "in_progress"}
])
```

#### 3. エラー発生時のTodo再計画

**エラー発生時の対応**:
```javascript
// エラー発生時は新しいタスクを追加
TodoWrite([
  {id: "4", content: "実装作業", status: "in_progress"}, // エラーで中断
  {id: "4-error", content: "エラー原因調査", status: "pending"},
  {id: "4-fix", content: "エラー修正", status: "pending"},
  {id: "4-retest", content: "修正後テスト", status: "pending"}
])
```

### 📝 具体的な使用例

#### 1. PRD更新作業のTodo管理
```javascript
TodoWrite([
  {id: "prd-1", content: "既存PRD（PRD_完全統合版.md）の全体構造確認", status: "pending"},
  {id: "prd-2", content: "追加機能（注釈・画像解析）の要件整理", status: "pending"},
  {id: "prd-3", content: "技術仕様セクションの詳細化", status: "pending"},
  {id: "prd-4", content: "ユースケースの具体的なシナリオ作成", status: "pending"},
  {id: "prd-5", content: "テスト計画とテストケースの策定", status: "pending"},
  {id: "prd-6", content: "API仕様の詳細ドキュメント作成", status: "pending"},
  {id: "prd-7", content: "PRDファイルの統合・更新", status: "pending"},
  {id: "prd-8", content: "関連ドキュメントとの整合性確認", status: "pending"}
])
```

#### 2. 機能実装のTodo管理
```javascript
TodoWrite([
  {id: "impl-1", content: "既存コード（main.js, annotation.js）の分析", status: "pending"},
  {id: "impl-2", content: "新機能の設計とアーキテクチャ検討", status: "pending"},
  {id: "impl-3", content: "フロントエンド実装（UI/UX改善）", status: "pending"},
  {id: "impl-4", content: "バックエンドAPI実装（Express.js）", status: "pending"},
  {id: "impl-5", content: "統合テスト（Playwright MCPによる自動テスト）", status: "pending"},
  {id: "impl-6", content: "エラーハンドリングとログ機能の実装", status: "pending"},
  {id: "impl-7", content: "パフォーマンス最適化", status: "pending"},
  {id: "impl-8", content: "ドキュメント更新（コメント・README等）", status: "pending"}
])
```

#### 3. デバッグ作業のTodo管理
```javascript
TodoWrite([
  {id: "debug-1", content: "問題の再現と現象の詳細確認", status: "pending"},
  {id: "debug-2", content: "ブラウザコンソールとネットワークログの収集", status: "pending"},
  {id: "debug-3", content: "サーバーログ（Docker/Express）の確認", status: "pending"},
  {id: "debug-4", content: "原因の特定と影響範囲の調査", status: "pending"},
  {id: "debug-5", content: "修正方針の検討と実装", status: "pending"},
  {id: "debug-6", content: "修正内容のテスト", status: "pending"},
  {id: "debug-7", content: "リグレッションテストの実行", status: "pending"},
  {id: "debug-8", content: "デバッグレポートの作成", status: "pending"}
])
```

#### 4. 複数ファイル編集のTodo管理
```javascript
TodoWrite([
  {id: "multi-1", content: "対象ファイルの特定と依存関係分析", status: "pending"},
  {id: "multi-2", content: "変更影響範囲の評価", status: "pending"},
  {id: "multi-3", content: "main.jsファイルの修正", status: "pending"},
  {id: "multi-4", content: "annotation.jsファイルの修正", status: "pending"},
  {id: "multi-5", content: "image-analyzer.jsファイルの修正", status: "pending"},
  {id: "multi-6", content: "server.jsファイルの修正", status: "pending"},
  {id: "multi-7", content: "package.jsonとDocker設定の更新", status: "pending"},
  {id: "multi-8", content: "統合テストと動作確認", status: "pending"}
])
```

### ✨ ベストプラクティス

#### 1. タスク完了時の即座の更新
```javascript
// ❌ 悪い例：複数タスクをまとめて更新
// 作業完了後にまとめて更新するのは避ける

// ✅ 良い例：1つずつ即座に更新
// タスク完了の度に即座にステータス更新
TodoWrite([
  {id: "1", content: "分析完了", status: "completed"}, // 完了時に即更新
  {id: "2", content: "実装中", status: "in_progress"}  // 開始時に即更新
])
```

#### 2. 見積もり時間の記載
```javascript
TodoWrite([
  {id: "1", content: "コードベース分析（予想：15分）", status: "pending"},
  {id: "2", content: "機能実装（予想：45分）", status: "pending"},
  {id: "3", content: "テスト作成（予想：30分）", status: "pending"}
])
```

#### 3. 依存関係の明確化
```javascript
TodoWrite([
  {id: "1", content: "API設計（基盤作業）", status: "pending"},
  {id: "2", content: "フロントエンド実装（depends on #1）", status: "pending"},
  {id: "3", content: "統合テスト（depends on #1, #2）", status: "pending"}
])
```

#### 4. ブロッカーの記録
```javascript
TodoWrite([
  {id: "3", content: "外部API連携実装", status: "pending"},
  {id: "3-blocker", content: "【ブロッカー】API仕様書の確認が必要", status: "pending"},
  {id: "4", content: "テスト実装", status: "pending"}
])
```

#### 5. 作業完了基準の明確化
```javascript
TodoWrite([
  {id: "1", content: "機能実装（完了基準：エラーなし、テスト通過、レビュー完了）", status: "pending"},
  {id: "2", content: "ドキュメント作成（完了基準：コード例含む、査読完了）", status: "pending"}
])
```

### 🚫 TodoWrite使用時の注意事項

#### 使用しない例外ケース
- 単一の簡単なファイル読み取り
- 1-2コマンドの簡単な状態確認
- 純粋に情報提供のみの作業
- 1分以内で完了する単純な作業

#### 避けるべき使用パターン
```javascript
// ❌ 避ける：粒度が不適切
TodoWrite([
  {id: "1", content: "すべてをやる", status: "pending"}  // 粗すぎ
])

// ❌ 避ける：複数タスクを同時にin_progress
TodoWrite([
  {id: "1", content: "実装", status: "in_progress"},
  {id: "2", content: "テスト", status: "in_progress"}  // 同時進行は避ける
])

// ❌ 避ける：完了していないのにcompletedにする
TodoWrite([
  {id: "1", content: "実装", status: "completed"}  // エラーが残っているのに完了にしない
])
```

### 🎯 まとめ：TodoWrite活用の黄金律

1. **3ステップ以上の作業は必須使用**
2. **1つずつin_progressにする**
3. **完了時は即座にステータス更新**
4. **適切な粒度でタスクを分割**
5. **エラー時は完了にしない**
6. **見積もり時間と依存関係を記録**
7. **ブロッカーは別タスクとして管理**

この原則に従うことで、効率的で品質の高い開発作業を継続的に実現できます。

## 🎯 5つのツール統合のまとめ：黄金律

### 📋 TodoWriteツール
- **役割**: 作業の可視化と進捗管理の中核
- **必須**: 3ステップ以上の作業は必ず使用
- **原則**: 1つずつin_progress、完了時即座更新

### 🤖 サブエージェント（Task tool）
- **役割**: 複雑な処理と専門的タスクの実行エンジン
- **必須**: コード実装、調査、テスト、ドキュメント作成
- **原則**: 複雑な作業は必ずサブエージェントに委譲

### 🔧 MCPサーバー
- **役割**: 外部システムとの統合ハブ
- **必須**: GitHub、Playwright、Context7、Fetch、IDE連携
- **原則**: MCP利用可能時は必ず優先使用

### ⚡ ClaudeCodeActions
- **役割**: Git操作とコードレビューの自動化エンジン
- **必須**: ブランチ管理、コミット、PR作成、品質チェック
- **原則**: 開発ワークフローの標準化と効率化

### 🌳 Git Worktrees
- **役割**: 並行開発と機能分離の基盤
- **必須**: 複数機能の同時開発、実験的機能、リリース管理
- **原則**: 機能別環境分離による効率的な開発

### 🔄 統合活用の黄金律

1. **順序の原則**: Worktrees → TodoWrite → サブエージェント → MCP → ClaudeCodeActions
2. **並列の原則**: 独立したタスクは可能な限り並列実行
3. **分離の原則**: 機能開発は独立したWorktreeで実行
4. **自動化の原則**: 手動操作はClaudeCodeActionsで自動化
5. **品質の原則**: すべてのフェーズで品質チェックを統合

### 🚀 最大効果を得るためのポイント

#### 開発効率の最大化
- **Git Worktrees**で環境分離 → **サブエージェント**で並列実装 → **MCP**で統合テスト

#### 品質保証の自動化  
- **TodoWrite**で完了基準明確化 → **ClaudeCodeActions**で自動レビュー → **MCP**で包括テスト

#### チーム開発の標準化
- **Git Worktrees**で作業分離 → **ClaudeCodeActions**で統一フロー → **TodoWrite**で進捗共有

この5つのツールの統合活用により、個人開発からチーム開発まで、あらゆる規模の開発プロジェクトで最高レベルの効率性と品質を実現できます。

## draw.io連携技術仕様

### 📚 技術仕様ドキュメント（再帰的インポート）

以下のドキュメントが自動的にインポートされ、完全な技術仕様が参照可能です：

#### draw.io統合戦略と機能仕様
@Flow.io連携機能仕様.md

#### XML最適化実装ガイド
@draw.io_XML最適化実装ガイド.md

#### XML形式実装詳細
@draw.io_XML形式実装ガイド.md

#### PlantUMLレンダリング戦略
@PlantUMLレンダリング段階的アプローチ.md

### 📌 クイックリファレンス（要約）

#### 手直し最小化の原則
- **グリッドスナップ**: 全座標を10px単位に調整
- **接続ポイント固定**: snapToPoint=1で正確な接続
- **スタイル統一**: Helvetica 12pt、標準カラーパレット

#### A/B案並列表現
- **実装方法**: Swimlaneを使用した並列レーン
- **色分け**: 案A（青）、案B（緑）、案C（橙）
- **未確定要素**: 点線表示（？マーク付き）

#### 4段階レンダリングアプローチ
1. **Phase 1 (MVP)**: Kroki API直接利用
2. **Phase 2**: カスタムKrokiラッパー
3. **Phase 3**: エンタープライズ機能
4. **Phase 4**: 内製レンダリング

## リソース

### ドキュメント
- [PlantUML公式](https://plantuml.com/)
- [Kroki API](https://kroki.io/)
- [Tesseract.js](https://tesseract.projectnaptha.com/)
- [Claude Code公式ドキュメント](https://docs.anthropic.com/en/docs/claude-code)
- [MCP公式仕様](https://spec.modelcontextprotocol.io/)

### 内部ドキュメント
- `PRD_完全統合版.md` - 製品要求定義
- `PlantUMLレンダリング段階的アプローチ.md` - 技術設計
- `draw.io_XML最適化実装ガイド.md` - 統合ガイド
- `Flow.io連携機能仕様.md` - draw.io統合戦略
- `draw.io_XML形式実装ガイド.md` - XML仕様詳細