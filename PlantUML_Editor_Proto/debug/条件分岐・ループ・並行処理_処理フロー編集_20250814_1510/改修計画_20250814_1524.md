# 条件分岐・ループ・並行処理 処理フロー編集機能 改修計画

**作成日時**: 2025-08-14 15:24:46
**対象ファイル**: C:\d\PlantUML\PlantUML_Editor_Proto\app.js
**問題**: 条件分岐、ループ、並行処理の処理フロー項目をクリックしても編集画面が開かない

## 1. 現状分析

### 問題の詳細
- **条件分岐（🔀）**: 新規追加は正常、処理フロー上の編集ができない
- **ループ（🔁）**: 同様に編集画面が開かない
- **並行処理（⚡）**: 同様の問題
- **メッセージ（📨）**: 正常に編集可能（比較対象）

### 技術的原因

#### 1. 意図的な編集機能の無効化
**ファイル**: app.js 行1146-1150
```javascript
// 編集イベント（条件分岐等は編集不可とする）
if (action.type !== 'condition' && action.type !== 'loop' && action.type !== 'parallel') {
    item.querySelector('.action-item-text').addEventListener('click', (e) => {
        this.editAction(parseInt(e.target.dataset.index));
    });
}
```

**問題**: 条件分岐・ループ・並行処理には意図的にクリックイベントリスナーが設定されていない

#### 2. データ構造の不整合
**通常のメッセージ（editAction関数で処理可能）**:
```javascript
{
    from: "アクター1",
    to: "アクター2", 
    text: "処理内容",
    uncertain: false,
    async: false
}
```

**条件分岐のデータ構造**:
```javascript
{
    type: 'condition',
    conditionType: 'if-else',
    conditionName: '在庫あり',
    trueBranch: [actions...],
    falseBranch: [actions...]
}
```

**ループのデータ構造**:
```javascript
{
    type: 'loop',
    loopCondition: 'ループ条件',
    loopActions: [actions...]
}
```

**並行処理のデータ構造**:
```javascript
{
    type: 'parallel',
    branches: [[actions...], [actions...]]
}
```

**結論**: 現在の`editAction`関数は通常のメッセージ専用で、条件分岐・ループ・並行処理の複雑なデータ構造に対応していない。

## 2. 影響範囲

### 影響を受ける機能
- 条件分岐の編集（条件名、分岐内容の変更）
- ループの編集（ループ条件、内部処理の変更）  
- 並行処理の編集（ブランチ数、各ブランチの処理変更）

### ユーザー体験への影響
- **重大**: 作成後の修正ができない → 削除して再作成が必要
- **作業効率**: 大幅な低下
- **学習コスト**: ユーザーの混乱を招く

## 3. 改修方針

### 基本方針
1. **段階的な機能拡張**: メッセージ編集機能を参考に各タイプ専用の編集機能を実装
2. **UI一貫性の維持**: 既存のモーダルダイアログパターンを踏襲
3. **データ整合性の保証**: 編集時のバリデーション強化

### 技術的アプローチ
**Phase 1**: イベントリスナーの拡張
- 条件分岐除外ロジックを削除
- タイプ別の編集関数へのルーティング実装

**Phase 2**: 専用編集関数の実装
- `editCondition(index)`: 条件分岐編集
- `editLoop(index)`: ループ編集  
- `editParallel(index)`: 並行処理編集

**Phase 3**: モーダルUI実装
- 各タイプに適したモーダルダイアログ
- バリデーションとエラーハンドリング

## 4. 実装詳細

### 4.1 Phase 1: イベントリスナーの修正

**修正対象**: app.js 行1146-1150

**現在のコード**:
```javascript
// 編集イベント（条件分岐等は編集不可とする）
if (action.type !== 'condition' && action.type !== 'loop' && action.type !== 'parallel') {
    item.querySelector('.action-item-text').addEventListener('click', (e) => {
        this.editAction(parseInt(e.target.dataset.index));
    });
}
```

**修正後のコード**:
```javascript
// 編集イベント（全てのタイプに対応）
item.querySelector('.action-item-text').addEventListener('click', (e) => {
    const index = parseInt(e.target.dataset.index);
    const action = this.actions[index];
    
    switch(action.type) {
        case 'condition':
            this.editCondition(index);
            break;
        case 'loop':
            this.editLoop(index);
            break;
        case 'parallel':
            this.editParallel(index);
            break;
        default:
            this.editAction(index);
            break;
    }
});
```

### 4.2 Phase 2: 条件分岐編集関数の実装

```javascript
editCondition(index) {
    const action = this.actions[index];
    
    // 既存データを編集用に保存
    this.editingConditionIndex = index;
    this.tempConditionData = {
        type: action.conditionType,
        name: action.conditionName,
        trueBranch: [...action.trueBranch],
        falseBranch: [...action.falseBranch]
    };
    
    // 条件分岐ビルダーを編集モードで表示
    this.showConditionEditModal(action);
}

showConditionEditModal(action) {
    // モーダルダイアログの作成
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="modal-dialog condition-edit-modal">
            <div class="modal-header">
                <h3>🔀 条件分岐の編集</h3>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <!-- 条件名入力 -->
                <div class="form-group">
                    <label>条件名:</label>
                    <input type="text" id="edit-condition-name" value="${action.conditionName}">
                </div>
                
                <!-- 条件タイプ選択 -->
                <div class="form-group">
                    <label>条件タイプ:</label>
                    <select id="edit-condition-type">
                        <option value="if-else" ${action.conditionType === 'if-else' ? 'selected' : ''}>if-else</option>
                        <option value="switch" ${action.conditionType === 'switch' ? 'selected' : ''}>switch</option>
                    </select>
                </div>
                
                <!-- 真の分岐 -->
                <div class="branch-section">
                    <h4>✅ 真の場合</h4>
                    <div id="edit-true-branch"></div>
                    <button class="btn-add-branch-action" data-branch="true">+ アクション追加</button>
                </div>
                
                <!-- 偽の分岐 -->
                <div class="branch-section">
                    <h4>❌ 偽の場合</h4>
                    <div id="edit-false-branch"></div>
                    <button class="btn-add-branch-action" data-branch="false">+ アクション追加</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-save-condition">✓ 保存</button>
                <button class="btn-cancel-condition">✗ キャンセル</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // イベントリスナーの設定
    this.setupConditionEditEventListeners(modal);
    
    // 既存データの表示
    this.displayExistingBranches(action);
}

setupConditionEditEventListeners(modal) {
    // 保存ボタン
    modal.querySelector('.btn-save-condition').addEventListener('click', () => {
        this.saveConditionEdit();
    });
    
    // キャンセルボタン
    modal.querySelector('.btn-cancel-condition').addEventListener('click', () => {
        this.cancelConditionEdit();
    });
    
    // 閉じるボタン
    modal.querySelector('.modal-close').addEventListener('click', () => {
        this.cancelConditionEdit();
    });
    
    // モーダル外クリック
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            this.cancelConditionEdit();
        }
    });
}

saveConditionEdit() {
    // バリデーション
    const name = document.getElementById('edit-condition-name').value.trim();
    if (!name) {
        this.showStatus('条件名を入力してください', 'error');
        return;
    }
    
    // データ更新
    this.actions[this.editingConditionIndex] = {
        type: 'condition',
        conditionType: document.getElementById('edit-condition-type').value,
        conditionName: name,
        trueBranch: [...this.tempConditionData.trueBranch],
        falseBranch: [...this.tempConditionData.falseBranch]
    };
    
    // UI更新
    this.updateActionList();
    this.updatePlantUML();
    
    // モーダル閉じる
    document.querySelector('.modal-overlay').remove();
    
    // ステータス表示
    this.showStatus('条件分岐を更新しました', 'success');
    
    // 編集状態のリセット
    this.editingConditionIndex = null;
    this.tempConditionData = null;
}

cancelConditionEdit() {
    document.querySelector('.modal-overlay').remove();
    this.editingConditionIndex = null;
    this.tempConditionData = null;
}
```

### 4.3 Phase 3: ループ編集関数の実装

```javascript
editLoop(index) {
    const action = this.actions[index];
    
    this.editingLoopIndex = index;
    this.tempLoopData = {
        condition: action.loopCondition,
        actions: [...action.loopActions]
    };
    
    this.showLoopEditModal(action);
}

showLoopEditModal(action) {
    // ループ編集モーダルの実装
    // 条件分岐と同様のパターンで実装
}
```

### 4.4 Phase 4: 並行処理編集関数の実装

```javascript
editParallel(index) {
    const action = this.actions[index];
    
    this.editingParallelIndex = index;
    this.tempParallelData = {
        branches: action.branches.map(branch => [...branch])
    };
    
    this.showParallelEditModal(action);
}

showParallelEditModal(action) {
    // 並行処理編集モーダルの実装
    // 複数ブランチの編集インターフェース
}
```

## 5. テスト計画

### 5.1 単体テスト
#### 条件分岐編集テスト
- [ ] 条件名の編集
- [ ] 条件タイプの変更（if-else ⇔ switch）
- [ ] 真の分岐にアクション追加・削除・編集
- [ ] 偽の分岐にアクション追加・削除・編集
- [ ] バリデーション（空の条件名等）

#### ループ編集テスト  
- [ ] ループ条件の編集
- [ ] ループ内アクションの追加・削除・編集
- [ ] バリデーション（空の条件等）

#### 並行処理編集テスト
- [ ] ブランチ数の追加・削除
- [ ] 各ブランチ内アクションの編集
- [ ] 最小ブランチ数のバリデーション

### 5.2 結合テスト
- [ ] 編集後のPlantUML出力の正確性
- [ ] 編集前後のデータ整合性
- [ ] 他の機能（ドラッグ&ドロップ等）との互換性

### 5.3 UI/UXテスト
- [ ] モーダルダイアログの表示・非表示
- [ ] ボタンの応答性
- [ ] エラーメッセージの適切性
- [ ] キーボードナビゲーション

### 5.4 動作確認シナリオ

#### シナリオ1: 条件分岐編集
1. 条件分岐を新規作成
2. 処理フロー上の条件分岐をクリック
3. 編集モーダルが表示されることを確認
4. 条件名を変更
5. 真の分岐に新しいアクションを追加
6. 保存して変更が反映されることを確認

#### シナリオ2: ループ編集
1. ループを新規作成
2. 処理フロー上のループをクリック
3. 編集モーダルが表示されることを確認
4. ループ条件を変更
5. ループ内にアクションを追加
6. 保存して変更が反映されることを確認

#### シナリオ3: 並行処理編集
1. 並行処理を新規作成  
2. 処理フロー上の並行処理をクリック
3. 編集モーダルが表示されることを確認
4. ブランチを追加
5. 各ブランチにアクションを追加
6. 保存して変更が反映されることを確認

## 6. リスク評価

### 潜在的リスク

#### 6.1 技術的リスク
**データ整合性の問題**
- **リスク**: 編集時のデータ構造の不整合
- **影響度**: 高
- **対策**: 厳密なバリデーション、データバックアップ機能

**パフォーマンスへの影響**
- **リスク**: モーダル表示・編集処理の重さ
- **影響度**: 中
- **対策**: 必要時のみDOM生成、イベントリスナーの適切な管理

#### 6.2 UI/UXリスク
**ユーザビリティの低下**
- **リスク**: 複雑な編集インターフェース
- **影響度**: 中
- **対策**: 直感的なUI設計、適切なヘルプテキスト

#### 6.3 保守性リスク
**コード複雑性の増加**
- **リスク**: 編集機能の追加による複雑化
- **影響度**: 中
- **対策**: 共通化可能な部分の関数化、適切なコメント

### 対策

#### データバックアップ機能
```javascript
backupActionData(index) {
    this.actionBackup = JSON.parse(JSON.stringify(this.actions[index]));
}

restoreActionData(index) {
    if (this.actionBackup) {
        this.actions[index] = this.actionBackup;
        this.actionBackup = null;
    }
}
```

#### バリデーション強化
```javascript
validateConditionData(data) {
    if (!data.name || data.name.trim() === '') {
        throw new Error('条件名は必須です');
    }
    
    if (data.trueBranch.length === 0) {
        throw new Error('真の場合のアクションは必須です');
    }
    
    return true;
}
```

## 7. 実装スケジュール

### Phase 1: 基盤実装（推定工数: 2時間）
- [x] 問題分析完了
- [ ] イベントリスナーの修正
- [ ] ルーティング機能の実装
- [ ] 基本的なエラーハンドリング

### Phase 2: 条件分岐編集（推定工数: 4時間）
- [ ] editCondition関数の実装
- [ ] 条件分岐編集モーダルUI
- [ ] バリデーション機能
- [ ] 基本テスト

### Phase 3: ループ編集（推定工数: 3時間）
- [ ] editLoop関数の実装
- [ ] ループ編集モーダルUI
- [ ] バリデーション機能
- [ ] 基本テスト

### Phase 4: 並行処理編集（推定工数: 4時間）
- [ ] editParallel関数の実装
- [ ] 並行処理編集モーダルUI
- [ ] 複数ブランチ管理機能
- [ ] 基本テスト

### Phase 5: 統合テスト・最適化（推定工数: 2時間）
- [ ] 全機能の統合テスト
- [ ] パフォーマンス最適化
- [ ] UI/UX改善
- [ ] ドキュメント更新

**総推定工数**: 15時間

## 8. 成功基準

### 機能要件
- [ ] 条件分岐の処理フロー上編集が可能
- [ ] ループの処理フロー上編集が可能
- [ ] 並行処理の処理フロー上編集が可能
- [ ] 編集後のPlantUML出力が正確
- [ ] データの整合性が保たれている

### 非機能要件
- [ ] 編集モーダルの表示が2秒以内
- [ ] エラー時の適切なメッセージ表示
- [ ] 直感的な操作性
- [ ] 既存機能への影響なし

### ユーザビリティ要件
- [ ] メッセージ編集と同等の操作性
- [ ] 明確なバリデーションメッセージ
- [ ] キャンセル時の適切な状態復帰

## 9. 次のステップ

1. **Phase 1の実装開始**
   - イベントリスナーの修正から開始
   - 基本的なルーティング機能の確認

2. **MVP(Minimum Viable Product)の定義**
   - 最低限の編集機能（条件名、条件の変更）
   - 基本的なバリデーション

3. **ユーザーフィードバックの収集**
   - 初期実装後のユーザビリティテスト
   - 改善点の特定

4. **継続的な改善**
   - パフォーマンス最適化
   - UI/UX改善
   - 追加機能の検討

---

## 備考

この改修計画は、現在のコードベースを詳細に分析した結果に基づいています。実装時には各フェーズで実際の動作確認を行い、必要に応じて計画を調整することを推奨します。

特に、条件分岐・ループ・並行処理の複雑なデータ構造を適切に扱うため、慎重なテストと検証が必要です。

**重要**: この機能拡張により、PlantUMLエディタの使用性が大幅に向上し、ユーザーの作業効率が改善されることが期待されます。