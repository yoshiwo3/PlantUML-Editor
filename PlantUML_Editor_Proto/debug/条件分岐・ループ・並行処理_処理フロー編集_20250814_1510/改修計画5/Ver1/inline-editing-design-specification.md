# PlantUMLã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†æ©Ÿèƒ½ è¨­è¨ˆä»•æ§˜æ›¸

**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**ä½œæˆæ—¥**: 2025å¹´8æœˆ15æ—¥  
**æœ€çµ‚æ›´æ–°**: 2025å¹´8æœˆ15æ—¥  
**ä½œæˆè€…**: software-doc-writer agent  

---

## 1. ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

### 1.1 æ¦‚è¦
æœ¬æ–‡æ›¸ã¯ã€PlantUMLã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã«ãŠã‘ã‚‹ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†æ©Ÿèƒ½ã®è¨­è¨ˆä»•æ§˜æ›¸ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ—¥æœ¬èªã§è¨˜è¿°ã—ãŸå‡¦ç†ãƒ•ãƒ­ãƒ¼ã‚’è¦–è¦šçš„ã«ç·¨é›†ã—ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§PlantUMLã‚³ãƒ¼ãƒ‰ã«å¤‰æ›ã™ã‚‹æ©Ÿèƒ½ã‚’å®šç¾©ã—ã¾ã™ã€‚

### 1.2 ç›®çš„ã¨èƒŒæ™¯
- **å•é¡Œ**: éã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãŒPlantUMLè¨˜æ³•ã‚’è¦šãˆã‚‹ã®ã¯å›°é›£
- **è§£æ±ºç­–**: æ—¥æœ¬èªå…¥åŠ›ã¨ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ç·¨é›†ã«ã‚ˆã‚‹ç›´æ„Ÿçš„ãªå›³è¡¨ä½œæˆ
- **ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ**: ä¼æ¥­ã®å–¶æ¥­è·ã€ä¼ç”»è·ã€é‹ç”¨æ‹…å½“è€…ï¼ˆéã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ï¼‰

### 1.3 é‡è¦ãªä¾¡å€¤ææ¡ˆ
1. **å­¦ç¿’ã‚³ã‚¹ãƒˆ0**: PlantUMLè¨˜æ³•ã®å­¦ç¿’ä¸è¦
2. **æ™‚é–“çŸ­ç¸®**: å›³è¡¨ä½œæˆæ™‚é–“ã‚’å¾“æ¥ã®1/5ã«çŸ­ç¸®ï¼ˆ3æ™‚é–“â†’30åˆ†ï¼‰
3. **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°**: ç·¨é›†ã¨åŒæ™‚ã«ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
4. **è¤‡é›‘æ€§å¯¾å¿œ**: æ¡ä»¶åˆ†å²ã€ãƒ«ãƒ¼ãƒ—ã€ä¸¦è¡Œå‡¦ç†ã®è¦–è¦šçš„ç·¨é›†

---

## 2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ãƒˆãƒ¼ãƒªãƒ¼

### 2.1 åŸºæœ¬æ“ä½œã‚¹ãƒˆãƒ¼ãƒªãƒ¼
```
As a å–¶æ¥­ä¼ç”»æ‹…å½“è€…
I want to æ—¥æœ¬èªã§ãƒ•ãƒ­ãƒ¼ã‚’è¨˜è¿°ã—ã¦è¦–è¦šçš„ã«ç·¨é›†
So that ä¼šè­°è³‡æ–™ç”¨ã®å›³è¡¨ã‚’çŸ­æ™‚é–“ã§ä½œæˆã§ãã‚‹
```

**å—ã‘å…¥ã‚ŒåŸºæº–**:
- æ—¥æœ¬èªå…¥åŠ›ã§ã‚¢ã‚¯ã‚¿ãƒ¼ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¨­å®šå¯èƒ½
- ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é †åºå¤‰æ›´å¯èƒ½
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§PlantUMLã‚³ãƒ¼ãƒ‰ç”Ÿæˆ

### 2.2 æ¡ä»¶åˆ†å²ç·¨é›†ã‚¹ãƒˆãƒ¼ãƒªãƒ¼
```
As a ECé‹ç”¨æ‹…å½“è€…
I want to ã€Œèªè¨¼æˆåŠŸã€ã¨ã€Œèªè¨¼å¤±æ•—ã€ã®æ¡ä»¶åˆ†å²ã‚’è¦–è¦šçš„ã«ç·¨é›†
So that ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ­ãƒ¼ã®è¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ˜ç¢ºã«è¡¨ç¾ã§ãã‚‹
```

**å—ã‘å…¥ã‚ŒåŸºæº–**:
- æ¡ä»¶å…¥åŠ›æ¬„ã§åˆ†å²æ¡ä»¶ã‚’æ—¥æœ¬èªè¨­å®š
- TRUE/FALSEåˆ†å²ãã‚Œãã‚Œã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ å¯èƒ½
- åˆ†å²ãƒ–ãƒ­ãƒƒã‚¯ã®å±•é–‹/æŠ˜ã‚ŠãŸãŸã¿æ©Ÿèƒ½

### 2.3 ãƒ«ãƒ¼ãƒ—å‡¦ç†ç·¨é›†ã‚¹ãƒˆãƒ¼ãƒªãƒ¼
```
As a ãƒ‡ãƒ¼ã‚¿å‡¦ç†æ‹…å½“è€…
I want to ã€Œãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹é™ã‚Šã€ãªã©ã®ãƒ«ãƒ¼ãƒ—æ¡ä»¶ã‚’è¨­å®š
So that ç¹°ã‚Šè¿”ã—å‡¦ç†ã®ãƒ•ãƒ­ãƒ¼ã‚’æ­£ç¢ºã«è¡¨ç¾ã§ãã‚‹
```

**å—ã‘å…¥ã‚ŒåŸºæº–**:
- ãƒ«ãƒ¼ãƒ—æ¡ä»¶ã‚’æ—¥æœ¬èªã§å…¥åŠ›å¯èƒ½
- ãƒ«ãƒ¼ãƒ—å†…ã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è‡ªç”±ã«è¿½åŠ å¯èƒ½
- ãƒã‚¹ãƒˆã—ãŸãƒ«ãƒ¼ãƒ—ã®è¦–è¦šçš„è¡¨ç¾

### 2.4 ä¸¦è¡Œå‡¦ç†ç·¨é›†ã‚¹ãƒˆãƒ¼ãƒªãƒ¼
```
As a ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆè€…
I want to è¤‡æ•°ã®APIã‚’åŒæ™‚å‘¼ã³å‡ºã—ã™ã‚‹å‡¦ç†ã‚’ä¸¦è¡Œãƒ–ãƒ­ãƒƒã‚¯ã§è¡¨ç¾
So that ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­è¨ˆã‚’é–¢ä¿‚è€…ã¨å…±æœ‰ã§ãã‚‹
```

**å—ã‘å…¥ã‚ŒåŸºæº–**:
- ã‚¿ãƒ–å½¢å¼ã§ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆ
- ã‚¹ãƒ¬ãƒƒãƒ‰è¿½åŠ /å‰Šé™¤æ©Ÿèƒ½
- éåŒæœŸçŸ¢å°ï¼ˆâ‡¢ï¼‰ã®è‡ªå‹•é¸æŠ

### 2.5 é«˜åº¦ç·¨é›†ã‚¹ãƒˆãƒ¼ãƒªãƒ¼
```
As a ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
I want to è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’æ®µéšçš„ã«æ§‹ç¯‰
So that ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã¨ã®èªè­˜åˆã‚ã›ã‚’åŠ¹ç‡åŒ–ã—ãŸã„
```

**å—ã‘å…¥ã‚ŒåŸºæº–**:
- ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã®æ®µéšçš„ç·¨é›†
- ãƒ–ãƒ­ãƒƒã‚¯å±•é–‹/æŠ˜ã‚ŠãŸãŸã¿ã«ã‚ˆã‚‹æƒ…å ±éšå±¤åŒ–
- ã‚³ãƒ”ãƒ¼&ãƒšãƒ¼ã‚¹ãƒˆæ©Ÿèƒ½

---

## 3. æ©Ÿèƒ½è¦ä»¶

### 3.1 ã‚³ã‚¢æ©Ÿèƒ½
| æ©Ÿèƒ½ID | æ©Ÿèƒ½å | å„ªå…ˆåº¦ | èª¬æ˜ |
|--------|--------|--------|------|
| F-001 | ã‚¢ã‚¯ã‚¿ãƒ¼ç®¡ç† | é«˜ | User, System, DB, APIã®é¸æŠãƒ»ç·¨é›† |
| F-002 | ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç·¨é›† | é«˜ | æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›† |
| F-003 | çŸ¢å°ã‚¿ã‚¤ãƒ—é¸æŠ | é«˜ | åŒæœŸ(â†’)ã€éåŒæœŸ(â‡¢)ã€æˆ»ã‚Šå€¤(âŸµ)é¸æŠ |
| F-004 | ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ä¸¦ã³æ›¿ãˆ | é«˜ | ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã«ã‚ˆã‚‹é †åºå¤‰æ›´ |
| F-005 | æ¡ä»¶åˆ†å²ç·¨é›† | é«˜ | IF-ELSEæ§‹é€ ã®è¦–è¦šçš„ç·¨é›† |
| F-006 | ãƒ«ãƒ¼ãƒ—ç·¨é›† | ä¸­ | WHILE/FORæ§‹é€ ã®è¦–è¦šçš„ç·¨é›† |
| F-007 | ä¸¦è¡Œå‡¦ç†ç·¨é›† | ä¸­ | PARæ§‹é€ ã®ã‚¿ãƒ–å¼ç·¨é›† |
| F-008 | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ | é«˜ | ç·¨é›†å†…å®¹ã®PlantUMLã‚³ãƒ¼ãƒ‰å³æ™‚åæ˜  |

### 3.2 UI/UXè¦ä»¶
| è¦ä»¶ID | è¦ä»¶å | èª¬æ˜ |
|--------|--------|------|
| UX-001 | ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ | ç”»é¢ã‚µã‚¤ã‚ºã«å¿œã˜ãŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ |
| UX-002 | ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ | WCAG 2.1 AAæº–æ‹  |
| UX-003 | ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ | ãƒã‚¦ã‚¹æ“ä½œã®ä»£æ›¿æ‰‹æ®µæä¾› |
| UX-004 | è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ | ãƒ›ãƒãƒ¼ã€ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ™‚ã®è¦–è¦šåŠ¹æœ |
| UX-005 | ã‚¨ãƒ©ãƒ¼è¡¨ç¤º | å…¥åŠ›ã‚¨ãƒ©ãƒ¼æ™‚ã®æ˜ç¢ºãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º |

### 3.3 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶
- **ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“**: ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã‹ã‚‰ç”»é¢æ›´æ–°ã¾ã§ < 100ms
- **ã‚³ãƒ¼ãƒ‰ç”Ÿæˆæ™‚é–“**: ç·¨é›†ã‹ã‚‰PlantUMLã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¾ã§ < 200ms
- **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡**: ãƒ–ãƒ©ã‚¦ã‚¶ã‚¿ãƒ–ã‚ãŸã‚Š < 50MB
- **ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º**: JavaScriptãƒãƒ³ãƒ‰ãƒ« < 500KB (gzipåœ§ç¸®å¾Œ)

---

## 4. æŠ€è¡“ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### 4.1 ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“æ§‹æˆ

```plantuml
@startuml "ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ"
!theme plain

package "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰" {
  component [ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†UI] as UI
  component [çŠ¶æ…‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ] as State
  component [PlantUMLãƒ‘ãƒ¼ã‚µãƒ¼] as Parser
  component [åŒæ–¹å‘åŒæœŸã‚¨ãƒ³ã‚¸ãƒ³] as Sync
}

package "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰" {
  component [PlantUMLç”ŸæˆAPI] as API
  component [å›³è¡¨ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°] as Renderer
}

database "ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸" as Storage

UI --> State : çŠ¶æ…‹æ›´æ–°
State --> Parser : ASTå¤‰æ›
Parser --> Sync : ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
Sync --> API : PlantUMLé€ä¿¡
API --> Renderer : SVGç”Ÿæˆ
State --> Storage : è‡ªå‹•ä¿å­˜

@enduml
```

### 4.2 ã‚¯ãƒ©ã‚¹æ§‹æˆå›³

```plantuml
@startuml "ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†ã‚¯ãƒ©ã‚¹å›³"
!theme plain

class InlineEditor {
  +selectedActors: Set<String>
  +actions: Array<Action>
  +currentMode: String
  +initializeEditor()
  +addAction()
  +deleteAction()
  +updateAction()
}

class ActionEditor {
  +actorFrom: String
  +actorTo: String
  +message: String
  +arrowType: String
  +render()
  +validate()
}

class ConditionalBlock {
  +condition: String
  +trueBranch: Array<Action>
  +falseBranch: Array<Action>
  +toggle()
  +addBranchAction()
}

class LoopBlock {
  +condition: String
  +actions: Array<Action>
  +loopType: String
  +validate()
}

class ParallelBlock {
  +threads: Array<Thread>
  +addThread()
  +removeThread()
  +switchThread()
}

class RealtimeSync {
  +syncInterval: Number
  +lastUpdateTime: Date
  +startSync()
  +stopSync()
  +generatePlantUML()
}

InlineEditor "1" --> "*" ActionEditor
InlineEditor "1" --> "*" ConditionalBlock
InlineEditor "1" --> "*" LoopBlock
InlineEditor "1" --> "*" ParallelBlock
InlineEditor "1" --> "1" RealtimeSync

@enduml
```

### 4.3 ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼å›³

```plantuml
@startuml "ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼"
!theme plain

actor User
participant "ç·¨é›†UI" as UI
participant "çŠ¶æ…‹ç®¡ç†" as State
participant "ãƒ‘ãƒ¼ã‚µãƒ¼" as Parser
participant "ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ" as CodeGen
participant "PlantUML API" as API

User -> UI : ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç·¨é›†
UI -> State : çŠ¶æ…‹æ›´æ–°è¦æ±‚
State -> Parser : ASTè§£æ
Parser -> CodeGen : PlantUMLã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
CodeGen -> API : ã‚³ãƒ¼ãƒ‰é€ä¿¡
API --> UI : SVGç”»åƒè¿”å´
UI --> User : æ›´æ–°ã•ã‚ŒãŸå›³è¡¨è¡¨ç¤º

note right of State
  - ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é…åˆ—ç®¡ç†
  - æ¡ä»¶åˆ†å²æ§‹é€ ç®¡ç†
  - ãƒ«ãƒ¼ãƒ—æ§‹é€ ç®¡ç†
  - ä¸¦è¡Œå‡¦ç†æ§‹é€ ç®¡ç†
end note

@enduml
```

---

## 5. UI/UXä»•æ§˜

### 5.1 ç”»é¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
- **2åˆ†å‰²ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ**: å·¦å´ç·¨é›†ãƒ‘ãƒãƒ«ã€å³å´PlantUMLã‚³ãƒ¼ãƒ‰è¡¨ç¤º
- **ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–**: ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆä»¥ä¸‹ã§ã‚¹ã‚¿ãƒƒã‚¯è¡¨ç¤º
- **æœ€å°è§£åƒåº¦**: 1024Ã—768pxå¯¾å¿œ

### 5.2 ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
```css
:root {
  --primary-color: #2196f3;    /* ãƒ¡ã‚¤ãƒ³ãƒ–ãƒ«ãƒ¼ */
  --secondary-color: #757575;  /* ã‚°ãƒ¬ãƒ¼ */
  --success-color: #4caf50;    /* æˆåŠŸã‚°ãƒªãƒ¼ãƒ³ */
  --warning-color: #ff9800;    /* è­¦å‘Šã‚ªãƒ¬ãƒ³ã‚¸ */
  --error-color: #f44336;      /* ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒƒãƒ‰ */
  --background-color: #f5f5f5; /* èƒŒæ™¯ã‚°ãƒ¬ãƒ¼ */
  --surface-color: #ffffff;    /* ã‚«ãƒ¼ãƒ‰èƒŒæ™¯ */
}
```

### 5.3 ã‚¿ã‚¤ãƒã‚°ãƒ©ãƒ•ã‚£
- **ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼**: 'Segoe UI', 'ãƒ¡ã‚¤ãƒªã‚ª', sans-serif
- **åŸºæœ¬ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º**: 14px
- **è¡Œé–“**: 1.6
- **è¦‹å‡ºã—æ¯”ç‡**: 1.25 (Type Scale)

### 5.4 ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ä»•æ§˜
| æ“ä½œ | å¯¾è±¡ | ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ | ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ |
|------|------|-----------|-------------|
| ãƒ›ãƒãƒ¼ | ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é …ç›® | box-shadowè¡¨ç¤º | 0.2s transition |
| ã‚¯ãƒªãƒƒã‚¯ | æ¡ä»¶åˆ†å²ãƒ–ãƒ­ãƒƒã‚¯ | å±•é–‹/æŠ˜ã‚ŠãŸãŸã¿ | ã‚¢ã‚¤ã‚³ãƒ³å›è»¢90Â° |
| ãƒ‰ãƒ©ãƒƒã‚° | ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é …ç›® | é †åºå¤‰æ›´ | åŠé€æ˜è¡¨ç¤º |
| ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ | å…¥åŠ›æ¬„ | border-colorå¤‰æ›´ | é’è‰²ãƒã‚¤ãƒ©ã‚¤ãƒˆ |

---

## 6. å®Ÿè£…è©³ç´°

### 6.1 HTMLæ§‹é€ 
```html
<div class="inline-editor">
  <div class="step-container">
    <div class="step-header">
      <span class="step-number">1</span>
      <span class="step-title">ã‚¹ãƒ†ãƒƒãƒ—å</span>
    </div>
    <div class="step-content">
      <!-- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é …ç›® -->
      <div class="action-item-inline">
        <span class="drag-handle">â˜°</span>
        <select class="actor-select-inline">...</select>
        <select class="arrow-type-inline">...</select>
        <select class="actor-select-inline">...</select>
        <input class="message-input-inline" />
        <div class="action-buttons-inline">
          <button class="btn-inline delete">ğŸ—‘ï¸</button>
          <button class="btn-inline question">ï¼Ÿ</button>
        </div>
      </div>
    </div>
  </div>
</div>
```

### 6.2 JavaScriptå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³
```javascript
class InlineActionEditor {
  constructor(container) {
    this.container = container;
    this.actions = [];
    this.bindEvents();
  }
  
  addAction() {
    const newAction = this.createActionElement();
    this.container.appendChild(newAction);
    this.actions.push(newAction);
    this.updatePlantUML();
  }
  
  deleteAction(actionElement) {
    const index = this.actions.indexOf(actionElement);
    if (index > -1) {
      this.actions.splice(index, 1);
      actionElement.remove();
      this.updatePlantUML();
    }
  }
  
  updatePlantUML() {
    const plantUMLCode = this.generatePlantUMLCode();
    this.syncToCodeEditor(plantUMLCode);
  }
}
```

### 6.3 çŠ¶æ…‹ç®¡ç†
```javascript
class EditorStateManager {
  constructor() {
    this.state = {
      actors: ['User', 'System', 'DB', 'API'],
      steps: [],
      currentStep: 0,
      editMode: 'inline'
    };
    this.listeners = [];
  }
  
  updateState(newState) {
    this.state = { ...this.state, ...newState };
    this.notifyListeners();
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
  }
  
  notifyListeners() {
    this.listeners.forEach(listener => listener(this.state));
  }
}
```

---

## 7. APIä»•æ§˜

### 7.1 PlantUMLã‚³ãƒ¼ãƒ‰ç”ŸæˆAPI
```javascript
/**
 * ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰PlantUMLã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
 * @param {Array} actions - ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é…åˆ—
 * @param {Object} options - ç”Ÿæˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
 * @returns {Promise<String>} PlantUMLã‚³ãƒ¼ãƒ‰
 */
async function generatePlantUMLCode(actions, options = {}) {
  // å®Ÿè£…è©³ç´°
}
```

### 7.2 çŠ¶æ…‹åŒæœŸAPI
```javascript
/**
 * ç·¨é›†çŠ¶æ…‹ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
 * @param {Object} editorState - ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼çŠ¶æ…‹
 */
function saveEditorState(editorState) {
  localStorage.setItem('plantuml-editor-state', JSON.stringify(editorState));
}

/**
 * ç·¨é›†çŠ¶æ…‹ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å¾©å…ƒ
 * @returns {Object} ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼çŠ¶æ…‹
 */
function loadEditorState() {
  const saved = localStorage.getItem('plantuml-editor-state');
  return saved ? JSON.parse(saved) : getDefaultState();
}
```

### 7.3 ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³API
```javascript
/**
 * ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¨­å®šã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
 * @param {Object} action - ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¨­å®š
 * @returns {Object} ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³çµæœ
 */
function validateAction(action) {
  const errors = [];
  
  if (!action.actorFrom) errors.push('é€ä¿¡å…ƒã‚¢ã‚¯ã‚¿ãƒ¼ãŒæœªè¨­å®š');
  if (!action.actorTo) errors.push('é€ä¿¡å…ˆã‚¢ã‚¯ã‚¿ãƒ¼ãŒæœªè¨­å®š');
  if (!action.message.trim()) errors.push('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç©º');
  
  return {
    isValid: errors.length === 0,
    errors
  };
}
```

---

## 8. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### 8.1 ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰
```plantuml
@startuml "ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰"
!theme plain

skinparam rectangle {
  BackgroundColor #e3f2fd
  BorderColor #1976d2
}

rectangle "E2Eãƒ†ã‚¹ãƒˆ (10%)\n- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚·ãƒŠãƒªã‚ª\n- ã‚¯ãƒ­ã‚¹ãƒ–ãƒ©ã‚¦ã‚¶ãƒ†ã‚¹ãƒˆ" as E2E
rectangle "çµ±åˆãƒ†ã‚¹ãƒˆ (30%)\n- APIé€£æºãƒ†ã‚¹ãƒˆ\n- ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“é€£æº" as Integration
rectangle "å˜ä½“ãƒ†ã‚¹ãƒˆ (60%)\n- é–¢æ•°ãƒ¬ãƒ™ãƒ«ãƒ†ã‚¹ãƒˆ\n- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ†ã‚¹ãƒˆ" as Unit

E2E
Integration
Unit

@enduml
```

### 8.2 ãƒ†ã‚¹ãƒˆç¨®åˆ¥ã¨å®Ÿè¡Œæˆ¦ç•¥

#### 8.2.1 å˜ä½“ãƒ†ã‚¹ãƒˆ (Jest)
```javascript
describe('InlineActionEditor', () => {
  test('ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ æ™‚ã«é…åˆ—ã«è¦ç´ ãŒè¿½åŠ ã•ã‚Œã‚‹', () => {
    const editor = new InlineActionEditor(document.createElement('div'));
    editor.addAction();
    expect(editor.actions.length).toBe(1);
  });
  
  test('PlantUMLã‚³ãƒ¼ãƒ‰ç”ŸæˆãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹', () => {
    const actions = [
      { actorFrom: 'User', actorTo: 'System', message: 'ãƒ­ã‚°ã‚¤ãƒ³' }
    ];
    const code = generatePlantUMLCode(actions);
    expect(code).toContain('User -> System : ãƒ­ã‚°ã‚¤ãƒ³');
  });
});
```

#### 8.2.2 çµ±åˆãƒ†ã‚¹ãƒˆ (Playwright)
```javascript
test('ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ ã‹ã‚‰å‰Šé™¤ã¾ã§ã®å®Œå…¨ãƒ•ãƒ­ãƒ¼', async ({ page }) => {
  await page.goto('http://localhost:3000');
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ 
  await page.click('.btn-add-action-inline');
  await page.fill('.message-input-inline', 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸');
  
  // PlantUMLã‚³ãƒ¼ãƒ‰ç”Ÿæˆç¢ºèª
  const code = await page.textContent('.code-editor');
  expect(code).toContain('ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸');
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‰Šé™¤
  await page.click('.btn-inline.delete');
  await page.click('text=OK'); // confirm dialog
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå‰Šé™¤ã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèª
  const actionCount = await page.locator('.action-item-inline').count();
  expect(actionCount).toBe(0);
});
```

#### 8.2.3 E2Eãƒ†ã‚¹ãƒˆ (Playwright)
```javascript
test('è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ä½œæˆã¨ç·¨é›†', async ({ page }) => {
  await page.goto('http://localhost:3000');
  
  // æ¡ä»¶åˆ†å²ä½œæˆ
  await page.click('text=æ¡ä»¶åˆ†å²');
  await page.fill('.process-condition-input', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼');
  
  // TRUEåˆ†å²ã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ 
  await page.click('.branch-true .btn-add-action-inline');
  
  // ãƒ«ãƒ¼ãƒ—è¿½åŠ 
  await page.click('text=ãƒ«ãƒ¼ãƒ—');
  
  // ä¸¦è¡Œå‡¦ç†è¿½åŠ 
  await page.click('text=ä¸¦è¡Œå‡¦ç†');
  await page.click('.thread-add-btn');
  
  // æœ€çµ‚çš„ãªPlantUMLã‚³ãƒ¼ãƒ‰ç¢ºèª
  const finalCode = await page.textContent('.code-editor');
  expect(finalCode).toContain('alt ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼');
  expect(finalCode).toContain('loop');
  expect(finalCode).toContain('par');
});
```

### 8.3 ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç’°å¢ƒ
- **ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ**: Node.js 20.x + Jest 29.x
- **çµ±åˆãƒ»E2Eãƒ†ã‚¹ãƒˆ**: Playwright (Chromium, Firefox, WebKit)
- **CI/CD**: GitHub Actions
- **ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™**: ãƒ©ã‚¤ãƒ³87%ä»¥ä¸Šã€ãƒ–ãƒ©ãƒ³ãƒ80%ä»¥ä¸Š

---

## 9. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

### 9.1 å…¥åŠ›æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
```javascript
/**
 * XSSæ”»æ’ƒå¯¾ç­–ã®ãŸã‚ã®å…¥åŠ›ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
 */
function sanitizeInput(input) {
  return input
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
}

/**
 * PlantUMLã‚³ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
 */
function validatePlantUMLInput(code) {
  const dangerousPatterns = [
    /!include\s+/i,           // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰é˜²æ­¢
    /!definelong\s+/i,        // ãƒã‚¯ãƒ­å®šç¾©é˜²æ­¢
    /!undefine\s+/i,          // ãƒã‚¯ãƒ­è§£é™¤é˜²æ­¢
    /<script/i,               // ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¿ã‚°é˜²æ­¢
    /javascript:/i            // JavaScript URLé˜²æ­¢
  ];
  
  return !dangerousPatterns.some(pattern => pattern.test(code));
}
```

### 9.2 Content Security Policy (CSP)
```html
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; 
               script-src 'self' 'unsafe-inline'; 
               style-src 'self' 'unsafe-inline'; 
               img-src 'self' data: https:; 
               connect-src 'self' https://www.plantuml.com;">
```

### 9.3 ãƒ‡ãƒ¼ã‚¿ä¿è­·
- **ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æš—å·åŒ–**: æ©Ÿå¯†æ€§ã®é«˜ã„ãƒ‡ãƒ¼ã‚¿ã¯æš—å·åŒ–ã—ã¦ä¿å­˜
- **ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†**: ã‚»ãƒƒã‚·ãƒ§ãƒ³æœ‰åŠ¹æœŸé™ã®é©åˆ‡ãªè¨­å®š
- **HTTPSå¼·åˆ¶**: æœ¬ç•ªç’°å¢ƒã§ã®HTTPSå¿…é ˆåŒ–

---

## 10. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶

### 10.1 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™å€¤
| ãƒ¡ãƒˆãƒªã‚¯ã‚¹ | ç›®æ¨™å€¤ | æ¸¬å®šæ–¹æ³• |
|-----------|--------|----------|
| First Contentful Paint | < 1.5ç§’ | Lighthouse |
| Largest Contentful Paint | < 2.5ç§’ | Lighthouse |
| Cumulative Layout Shift | < 0.1 | Lighthouse |
| Time to Interactive | < 3.0ç§’ | Lighthouse |
| JavaScript Bundle Size | < 500KB | Webpack Bundle Analyzer |

### 10.2 æœ€é©åŒ–æˆ¦ç•¥

#### 10.2.1 ã‚³ãƒ¼ãƒ‰åˆ†å‰²
```javascript
// å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ã‚ˆã‚‹ã‚³ãƒ¼ãƒ‰åˆ†å‰²
const loadEditor = async () => {
  const { InlineEditor } = await import('./components/InlineEditor');
  return new InlineEditor();
};

// æ¡ä»¶åˆ†å²ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®é…å»¶èª­ã¿è¾¼ã¿
const loadConditionalEditor = async () => {
  const { ConditionalEditor } = await import('./components/ConditionalEditor');
  return ConditionalEditor;
};
```

#### 10.2.2 ãƒ¡ãƒ¢åŒ–ã¨ãƒ‡ãƒã‚¦ãƒ³ã‚¹
```javascript
// PlantUMLã‚³ãƒ¼ãƒ‰ç”Ÿæˆã®ãƒ¡ãƒ¢åŒ–
const memoizedGenerateCode = useMemo(() => {
  return (actions) => generatePlantUMLCode(actions);
}, [actions]);

// ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹
const debouncedSync = debounce((state) => {
  syncToServer(state);
}, 300);
```

#### 10.2.3 ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
```javascript
// å¤§é‡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é …ç›®ã«å¯¾ã™ã‚‹ä»®æƒ³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Ÿè£…
class VirtualActionList {
  constructor(container, items) {
    this.container = container;
    this.items = items;
    this.visibleItems = 20; // è¡¨ç¤ºã™ã‚‹é …ç›®æ•°
    this.itemHeight = 60;   // å„é …ç›®ã®é«˜ã•
  }
  
  render(startIndex) {
    const endIndex = Math.min(startIndex + this.visibleItems, this.items.length);
    const visibleItems = this.items.slice(startIndex, endIndex);
    
    // DOMã®æ›´æ–°ï¼ˆæœ€é©åŒ–æ¸ˆã¿ï¼‰
    this.updateDOM(visibleItems, startIndex);
  }
}
```

---

## 11. å®Ÿè£…æ¤œè¨¼ã¨è¿½åŠ è¦ä»¶

### 11.1 ä¾¡å€¤ææ¡ˆã®å®Ÿç¾å¯èƒ½æ€§è©•ä¾¡

ç¾åœ¨ã®è¨­è¨ˆä»•æ§˜æ›¸ã®å®Ÿè£…ä¾‹ã«å¯¾ã—ã¦è©³ç´°ãªæ¤œè¨¼ã‚’è¡Œã£ãŸçµæœã€ä»¥ä¸‹ã®å®Ÿç¾å¯èƒ½æ€§è©•ä¾¡ãŒåˆ¤æ˜ã—ã¾ã—ãŸï¼š

| ä¾¡å€¤ææ¡ˆé …ç›® | ç¾åœ¨ã®å®Ÿç¾åº¦ | ä¸è¶³ç‡ | ä¸»è¦ãªå•é¡Œç‚¹ |
|-------------|-------------|--------|-------------|
| å­¦ç¿’ã‚³ã‚¹ãƒˆ0 | 20% | 80% | æ—¥æœ¬èªâ†’PlantUMLå¤‰æ›ã‚¨ãƒ³ã‚¸ãƒ³ãŒä¸å®Œå…¨ |
| æ™‚é–“çŸ­ç¸®1/5 | 15% | 85% | ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ©Ÿèƒ½ãƒ»è‡ªå‹•è£œå®ŒãŒæœªå®Ÿè£… |
| ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–° | 40% | 60% | WebSocketåŒæœŸã‚·ã‚¹ãƒ†ãƒ ãŒåŸºæœ¬å®Ÿè£…ã®ã¿ |
| è¤‡é›‘æ€§å¯¾å¿œ | 10% | 90% | æ¡ä»¶åˆ†å²ãƒ»ãƒ«ãƒ¼ãƒ—ãƒ»ä¸¦è¡Œå‡¦ç†ã®å®Ÿè£…ãŒä¸ååˆ† |

**ç·åˆè©•ä¾¡**: ç¾åœ¨ã®å®Ÿè£…ã§ã¯ç´„20%ã®æ©Ÿèƒ½ã—ã‹å®Ÿç¾ã§ãã¦ãŠã‚‰ãšã€**80%ã®è¿½åŠ å®Ÿè£…ãŒå¿…è¦**

### 11.2 ä¸è¶³ã—ã¦ã„ã‚‹æ ¸å¿ƒå®Ÿè£…

#### 11.2.1 PlantUMLå¤‰æ›ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆå®Œå…¨å®Ÿè£…ï¼‰

ç¾åœ¨ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã§ã¯åŸºæœ¬çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã®ã¿ã§ã€å®Ÿéš›ã®æ—¥æœ¬èªè§£æã«ã¯ä¸ååˆ†ã§ã™ã€‚ä»¥ä¸‹ã®å®Œå…¨å®Ÿè£…ãŒå¿…è¦ã§ã™ï¼š

```javascript
class PlantUMLConverter {
  constructor() {
    this.keywords = {
      actors: ['User', 'System', 'DB', 'API', 'Service'],
      arrows: {
        sync: '->',
        async: '->>',
        return: '-->>',
        create: '-->',
        destroy: '--x'
      },
      // æ—¥æœ¬èªå‹•è©ã®é¡å‹åŒ–
      verbTypes: {
        request: ['è¦æ±‚', 'é€ä¿¡', 'ä¾é ¼', 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆ'],
        response: ['è¿”å´', 'å¿œç­”', 'ãƒ¬ã‚¹ãƒãƒ³ã‚¹', 'å›ç­”'],
        process: ['å‡¦ç†', 'å®Ÿè¡Œ', 'é–‹å§‹', 'çµ‚äº†'],
        create: ['ä½œæˆ', 'ç”Ÿæˆ', 'æ–°è¦'],
        update: ['æ›´æ–°', 'å¤‰æ›´', 'ä¿®æ­£'],
        delete: ['å‰Šé™¤', 'é™¤å»', 'ç ´æ£„']
      }
    };
    this.stateStack = []; // ãƒã‚¹ãƒˆæ§‹é€ ç®¡ç†
  }

  convertFromJapanese(text) {
    const lines = text.split('\n').filter(line => line.trim());
    let plantUML = '@startuml\n';
    
    // å‰å‡¦ç†ï¼šã‚¢ã‚¯ã‚¿ãƒ¼è‡ªå‹•æ¤œå‡º
    const detectedActors = this.detectActors(lines);
    detectedActors.forEach(actor => {
      plantUML += `participant ${actor}\n`;
    });
    plantUML += '\n';
    
    // å„è¡Œã®è§£æã¨å¤‰æ›
    lines.forEach((line, index) => {
      const parsed = this.parseLine(line, index);
      if (parsed) {
        plantUML += this.generatePlantUMLLine(parsed) + '\n';
      }
    });
    
    plantUML += '@enduml';
    return plantUML;
  }

  detectActors(lines) {
    const actors = new Set();
    const actorPatterns = [
      /(.+?)ãŒ/g,
      /(.+?)ã‹ã‚‰/g,
      /(.+?)ã«/g,
      /(.+?)ã¸/g
    ];
    
    lines.forEach(line => {
      actorPatterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(line)) !== null) {
          const actor = this.normalizeActor(match[1].trim());
          if (actor) actors.add(actor);
        }
      });
    });
    
    return Array.from(actors);
  }

  parseLine(line, lineIndex) {
    // æ§‹é€ åˆ¶å¾¡ãƒ‘ã‚¿ãƒ¼ãƒ³
    const structurePatterns = [
      { pattern: /^ã‚‚ã—(.+?)ãªã‚‰$/, type: 'conditional', condition: '$1' },
      { pattern: /^(.+?)ã®é–“ç¹°ã‚Šè¿”ã™$/, type: 'loop', condition: '$1', loopType: 'while' },
      { pattern: /^(.+?)å›ç¹°ã‚Šè¿”ã™$/, type: 'loop', condition: '$1', loopType: 'for' },
      { pattern: /^ä¸¦è¡Œã—ã¦$/, type: 'parallel', threads: 2 },
      { pattern: /^ãã†ã§ãªã‘ã‚Œã°$/, type: 'else' },
      { pattern: /^çµ‚äº†$/, type: 'end' }
    ];
    
    // æ§‹é€ åˆ¶å¾¡ã®å‡¦ç†
    for (const struct of structurePatterns) {
      const match = line.match(struct.pattern);
      if (match) {
        return this.processStructure(struct, match, lineIndex);
      }
    }
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
    const actionPatterns = [
      /(.+?)ãŒ(.+?)ã«ã€Œ(.+?)ã€ã‚’(é€ä¿¡|è¦æ±‚|è¿”å´)/,
      /(.+?)ã‹ã‚‰(.+?)ã¸ã€Œ(.+?)ã€ã‚’(é€ä¿¡|è¦æ±‚|è¿”å´)/,
      /(.+?)ãŒ(.+?)ã‚’(å®Ÿè¡Œ|å‡¦ç†|é–‹å§‹|çµ‚äº†)/,
      /(.+?)ã‚’(.+?)ã«(ä¿å­˜|æ›´æ–°|å‰Šé™¤)/,
      /(.+?)ã‹ã‚‰(.+?)ã‚’(å–å¾—|èª­ã¿è¾¼ã¿)/
    ];
    
    for (const pattern of actionPatterns) {
      const match = line.match(pattern);
      if (match) {
        return this.extractAction(match);
      }
    }
    
    return null;
  }

  processStructure(struct, match, lineIndex) {
    switch (struct.type) {
      case 'conditional':
        this.stateStack.push({ type: 'alt', condition: match[1], line: lineIndex });
        return { type: 'structure', subtype: 'alt', condition: match[1] };
      
      case 'loop':
        this.stateStack.push({ type: 'loop', condition: match[1], loopType: struct.loopType, line: lineIndex });
        return { type: 'structure', subtype: 'loop', condition: match[1], loopType: struct.loopType };
      
      case 'parallel':
        this.stateStack.push({ type: 'par', threads: struct.threads, line: lineIndex });
        return { type: 'structure', subtype: 'par' };
      
      case 'else':
        return { type: 'structure', subtype: 'else' };
      
      case 'end':
        const lastState = this.stateStack.pop();
        return { type: 'structure', subtype: 'end', originalType: lastState?.type };
    }
    
    return null;
  }

  extractAction(match) {
    const from = this.normalizeActor(match[1]);
    const to = this.normalizeActor(match[2]);
    const message = match[3] || match[2]; // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¾ãŸã¯å‡¦ç†å†…å®¹
    const verb = match[4] || match[3];
    
    return {
      type: 'action',
      from: from,
      to: to,
      message: message,
      arrowType: this.getArrowType(verb),
      indent: this.getCurrentIndent()
    };
  }

  normalizeActor(actor) {
    const mapping = {
      'ãƒ¦ãƒ¼ã‚¶ãƒ¼': 'User',
      'ãƒ¦ãƒ¼ã‚¶': 'User',
      'ã‚·ã‚¹ãƒ†ãƒ ': 'System',
      'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹': 'Database',
      'DB': 'Database',
      'API': 'API',
      'ã‚µãƒ¼ãƒãƒ¼': 'Server',
      'ã‚µãƒ¼ãƒ': 'Server',
      'ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ': 'Client',
      'ãƒ–ãƒ©ã‚¦ã‚¶': 'Browser'
    };
    
    return mapping[actor] || actor.replace(/[^\w]/g, '');
  }

  getArrowType(verb) {
    if (this.keywords.verbTypes.request.includes(verb)) return '->';
    if (this.keywords.verbTypes.response.includes(verb)) return '-->';
    if (this.keywords.verbTypes.process.includes(verb)) return '->>';
    return '->'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
  }

  getCurrentIndent() {
    return '  '.repeat(this.stateStack.length);
  }

  generatePlantUMLLine(parsed) {
    switch (parsed.type) {
      case 'action':
        return `${parsed.indent}${parsed.from} ${parsed.arrowType} ${parsed.to} : ${parsed.message}`;
      
      case 'structure':
        return this.generateStructureLine(parsed);
      
      default:
        return '';
    }
  }

  generateStructureLine(struct) {
    const indent = this.getCurrentIndent();
    
    switch (struct.subtype) {
      case 'alt':
        return `${indent}alt ${struct.condition}`;
      case 'loop':
        return `${indent}loop ${struct.condition}`;
      case 'par':
        return `${indent}par`;
      case 'else':
        return `${indent}else`;
      case 'end':
        return `${indent}end`;
      default:
        return '';
    }
  }

  // ASTæ§‹é€ è§£æï¼ˆé«˜åº¦ãªæ©Ÿèƒ½ï¼‰
  parseToAST(actions) {
    const ast = {
      type: 'sequence',
      children: [],
      metadata: {
        actors: new Set(),
        complexity: 0
      }
    };
    
    let currentNode = ast;
    const nodeStack = [ast];
    
    actions.forEach(action => {
      if (action.type === 'structure') {
        const newNode = this.createStructureNode(action);
        currentNode.children.push(newNode);
        
        if (['alt', 'loop', 'par'].includes(action.subtype)) {
          nodeStack.push(newNode);
          currentNode = newNode;
        } else if (action.subtype === 'end') {
          nodeStack.pop();
          currentNode = nodeStack[nodeStack.length - 1];
        }
      } else if (action.type === 'action') {
        currentNode.children.push(action);
        ast.metadata.actors.add(action.from);
        ast.metadata.actors.add(action.to);
        ast.metadata.complexity++;
      }
    });
    
    return ast;
  }

  createStructureNode(action) {
    return {
      type: action.subtype,
      condition: action.condition,
      children: [],
      metadata: {
        startLine: action.line,
        complexity: 1
      }
    };
  }

  // ã‚³ãƒ¼ãƒ‰æœ€é©åŒ–æ©Ÿèƒ½
  optimizeGeneratedCode(ast) {
    // ä¸è¦ãªç©ºè¡Œå‰Šé™¤
    // é‡è¤‡ã™ã‚‹participantå®£è¨€ã®çµ±åˆ
    // ãƒã‚¹ãƒˆãƒ¬ãƒ™ãƒ«ã®æœ€é©åŒ–
    return this.generateOptimizedCode(ast);
  }

  generateOptimizedCode(ast) {
    let code = '@startuml\n';
    
    // ã‚¢ã‚¯ã‚¿ãƒ¼å®£è¨€ã®æœ€é©åŒ–
    const actors = Array.from(ast.metadata.actors);
    actors.forEach(actor => {
      code += `participant ${actor}\n`;
    });
    code += '\n';
    
    // æ§‹é€ çš„ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
    code += this.generateNodeCode(ast, 0);
    code += '@enduml';
    
    return code;
  }

  generateNodeCode(node, depth) {
    let code = '';
    const indent = '  '.repeat(depth);
    
    if (node.type === 'action') {
      code += `${indent}${node.from} ${node.arrowType} ${node.to} : ${node.message}\n`;
    } else if (node.children) {
      if (node.type === 'alt') {
        code += `${indent}alt ${node.condition}\n`;
      } else if (node.type === 'loop') {
        code += `${indent}loop ${node.condition}\n`;
      } else if (node.type === 'par') {
        code += `${indent}par\n`;
      }
      
      node.children.forEach(child => {
        code += this.generateNodeCode(child, depth + 1);
      });
      
      if (['alt', 'loop', 'par'].includes(node.type)) {
        code += `${indent}end\n`;
      }
    }
    
    return code;
  }
}
```

#### 11.2.2 ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½ï¼ˆå®Œå…¨å®Ÿè£…ï¼‰

ç¾åœ¨ã®ä»•æ§˜ã§ã¯åŸºæœ¬çš„ãªã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ã®ã¿ã§ã™ã€‚å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ãƒ¬ãƒ™ãƒ«ã§ã¯ä»¥ä¸‹ã®å®Œå…¨å®Ÿè£…ãŒå¿…è¦ã§ã™ï¼š

```javascript
class DragDropManager {
  constructor(container) {
    this.container = container;
    this.draggedElement = null;
    this.placeholder = null;
    this.scrollContainer = null;
    this.autoScrollInterval = null;
    this.touchStartPos = null;
    this.isDragging = false;
  }

  initSortable() {
    this.setupScrollContainer();
    this.bindEvents();
    this.setupMutationObserver();
  }

  setupScrollContainer() {
    this.scrollContainer = this.container.closest('.scrollable') || window;
  }

  bindEvents() {
    // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
    this.container.addEventListener('mousedown', this.handleMouseDown.bind(this));
    document.addEventListener('mousemove', this.handleMouseMove.bind(this));
    document.addEventListener('mouseup', this.handleMouseUp.bind(this));
    
    // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œï¼‰
    this.container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
    document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
    document.addEventListener('touchend', this.handleTouchEnd.bind(this));
    
    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ï¼‰
    this.container.addEventListener('keydown', this.handleKeyDown.bind(this));
  }

  setupMutationObserver() {
    // å‹•çš„ãªè¦ç´ è¿½åŠ ã«å¯¾å¿œ
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('action-item-inline')) {
              this.makeElementDraggable(node);
            }
          });
        }
      });
    });
    
    this.observer.observe(this.container, { childList: true, subtree: true });
  }

  makeElementDraggable(element) {
    element.draggable = true;
    element.tabIndex = 0; // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¯¾å¿œ
    element.setAttribute('aria-grabbed', 'false');
    
    // ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ«ã®è¿½åŠ 
    const handle = element.querySelector('.drag-handle');
    if (handle) {
      handle.style.cursor = 'grab';
      handle.setAttribute('aria-label', 'ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç§»å‹•');
    }
  }

  handleMouseDown(e) {
    const item = e.target.closest('.action-item-inline');
    const handle = e.target.closest('.drag-handle');
    
    if (!item || !handle) return;
    
    this.startDrag(e, item);
  }

  handleTouchStart(e) {
    if (e.touches.length !== 1) return;
    
    const touch = e.touches[0];
    const item = e.target.closest('.action-item-inline');
    const handle = e.target.closest('.drag-handle');
    
    if (!item || !handle) return;
    
    this.touchStartPos = { x: touch.clientX, y: touch.clientY };
    
    // é•·æŠ¼ã—æ¤œå‡ºã®ãŸã‚ã®ã‚¿ã‚¤ãƒãƒ¼
    this.longPressTimer = setTimeout(() => {
      this.startDrag(e, item, touch);
    }, 500);
  }

  startDrag(e, item, touch = null) {
    e.preventDefault();
    
    this.isDragging = true;
    this.draggedElement = item;
    
    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
    item.style.opacity = '0.6';
    item.style.transform = 'rotate(2deg)';
    item.setAttribute('aria-grabbed', 'true');
    
    // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ä½œæˆ
    this.createPlaceholder(item);
    
    // ã‚´ãƒ¼ã‚¹ãƒˆè¦ç´ ä½œæˆï¼ˆã‚«ã‚¹ã‚¿ãƒ è¡¨ç¤ºï¼‰
    this.createGhostElement(item, touch || e);
    
    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
    this.dispatchDragEvent('dragstart', item);
    
    // è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é–‹å§‹
    this.startAutoScroll();
  }

  createPlaceholder(item) {
    this.placeholder = document.createElement('div');
    this.placeholder.className = 'drag-placeholder';
    this.placeholder.style.height = item.offsetHeight + 'px';
    this.placeholder.style.background = 'linear-gradient(45deg, #e3f2fd 25%, transparent 25%), linear-gradient(-45deg, #e3f2fd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #e3f2fd 75%), linear-gradient(-45deg, transparent 75%, #e3f2fd 75%)';
    this.placeholder.style.backgroundSize = '20px 20px';
    this.placeholder.style.backgroundPosition = '0 0, 0 10px, 10px -10px, -10px 0px';
    this.placeholder.style.border = '2px dashed #2196f3';
    this.placeholder.style.borderRadius = '4px';
    this.placeholder.style.marginBottom = '8px';
    this.placeholder.style.opacity = '0.7';
    this.placeholder.style.transition = 'all 0.2s ease';
    this.placeholder.setAttribute('aria-hidden', 'true');
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
    this.placeholder.style.animation = 'pulse 1s infinite';
  }

  createGhostElement(item, e) {
    this.ghostElement = item.cloneNode(true);
    this.ghostElement.className = 'drag-ghost';
    this.ghostElement.style.position = 'fixed';
    this.ghostElement.style.pointerEvents = 'none';
    this.ghostElement.style.zIndex = '9999';
    this.ghostElement.style.opacity = '0.8';
    this.ghostElement.style.transform = 'rotate(5deg) scale(1.05)';
    this.ghostElement.style.boxShadow = '0 10px 25px rgba(0,0,0,0.3)';
    this.ghostElement.style.borderRadius = '8px';
    
    document.body.appendChild(this.ghostElement);
    this.updateGhostPosition(e);
  }

  updateGhostPosition(e) {
    if (!this.ghostElement) return;
    
    const x = (e.clientX || e.touches[0].clientX) - (this.ghostElement.offsetWidth / 2);
    const y = (e.clientY || e.touches[0].clientY) - (this.ghostElement.offsetHeight / 2);
    
    this.ghostElement.style.left = x + 'px';
    this.ghostElement.style.top = y + 'px';
  }

  handleMouseMove(e) {
    if (!this.isDragging) return;
    
    e.preventDefault();
    this.updateGhostPosition(e);
    this.handleDragOver(e);
    this.checkAutoScroll(e);
  }

  handleTouchMove(e) {
    if (!this.isDragging) return;
    
    e.preventDefault();
    
    const touch = e.touches[0];
    this.updateGhostPosition(e);
    this.handleDragOver(touch);
    this.checkAutoScroll(touch);
  }

  handleDragOver(e) {
    const afterElement = this.getDragAfterElement(this.container, e.clientY || e.touches[0].clientY);
    const targetContainer = this.container;
    
    if (afterElement == null) {
      targetContainer.appendChild(this.placeholder);
    } else {
      targetContainer.insertBefore(this.placeholder, afterElement);
    }
    
    // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    this.placeholder.style.transform = 'scaleY(1)';
    this.placeholder.style.opacity = '1';
    
    // ã‚¹ãƒ ãƒ¼ã‚ºãªãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
    setTimeout(() => {
      this.placeholder.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    }, 0);
  }

  getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.action-item-inline:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  checkAutoScroll(e) {
    const viewport = this.scrollContainer === window ? window : this.scrollContainer;
    const scrollThreshold = 50;
    const scrollSpeed = 5;
    
    let scrollY = 0;
    const mouseY = e.clientY || e.touches[0].clientY;
    
    if (viewport === window) {
      if (mouseY < scrollThreshold) {
        scrollY = -scrollSpeed;
      } else if (mouseY > window.innerHeight - scrollThreshold) {
        scrollY = scrollSpeed;
      }
    } else {
      const rect = viewport.getBoundingClientRect();
      if (mouseY < rect.top + scrollThreshold) {
        scrollY = -scrollSpeed;
      } else if (mouseY > rect.bottom - scrollThreshold) {
        scrollY = scrollSpeed;
      }
    }
    
    if (scrollY !== 0) {
      if (viewport === window) {
        window.scrollBy(0, scrollY);
      } else {
        viewport.scrollTop += scrollY;
      }
    }
  }

  startAutoScroll() {
    this.autoScrollInterval = setInterval(() => {
      // è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‡¦ç†ã¯checkAutoScrollã§è¡Œã†
    }, 16); // 60fps
  }

  handleMouseUp(e) {
    this.endDrag(e);
  }

  handleTouchEnd(e) {
    clearTimeout(this.longPressTimer);
    if (this.isDragging) {
      this.endDrag(e);
    }
  }

  endDrag(e) {
    if (!this.isDragging) return;
    
    this.isDragging = false;
    
    // ãƒ‰ãƒ©ãƒƒã‚°è¦ç´ ã®å¾©å…ƒ
    if (this.draggedElement) {
      this.draggedElement.style.opacity = '';
      this.draggedElement.style.transform = '';
      this.draggedElement.setAttribute('aria-grabbed', 'false');
      
      // æ–°ã—ã„ä½ç½®ã«ç§»å‹•
      if (this.placeholder && this.placeholder.parentNode) {
        this.placeholder.parentNode.insertBefore(this.draggedElement, this.placeholder);
      }
    }
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    this.removePlaceholder();
    this.removeGhostElement();
    this.stopAutoScroll();
    
    // é †åºæ›´æ–°
    this.updateActionOrder();
    
    // ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£é€šçŸ¥
    this.announceOrderChange();
    
    // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
    this.dispatchDragEvent('dragend', this.draggedElement);
    
    this.draggedElement = null;
  }

  removePlaceholder() {
    if (this.placeholder && this.placeholder.parentNode) {
      this.placeholder.style.opacity = '0';
      this.placeholder.style.transform = 'scaleY(0)';
      setTimeout(() => {
        if (this.placeholder && this.placeholder.parentNode) {
          this.placeholder.parentNode.removeChild(this.placeholder);
        }
      }, 200);
    }
  }

  removeGhostElement() {
    if (this.ghostElement) {
      this.ghostElement.style.opacity = '0';
      this.ghostElement.style.transform = 'rotate(5deg) scale(0.8)';
      setTimeout(() => {
        if (this.ghostElement && this.ghostElement.parentNode) {
          this.ghostElement.parentNode.removeChild(this.ghostElement);
        }
      }, 200);
    }
  }

  stopAutoScroll() {
    if (this.autoScrollInterval) {
      clearInterval(this.autoScrollInterval);
      this.autoScrollInterval = null;
    }
  }

  handleKeyDown(e) {
    const item = e.target.closest('.action-item-inline');
    if (!item) return;
    
    const items = [...this.container.querySelectorAll('.action-item-inline')];
    const currentIndex = items.indexOf(item);
    
    switch (e.key) {
      case 'ArrowUp':
        if (e.ctrlKey && currentIndex > 0) {
          e.preventDefault();
          this.moveElement(item, items[currentIndex - 1], 'before');
          item.focus();
        }
        break;
      
      case 'ArrowDown':
        if (e.ctrlKey && currentIndex < items.length - 1) {
          e.preventDefault();
          this.moveElement(item, items[currentIndex + 1], 'after');
          item.focus();
        }
        break;
      
      case ' ':
      case 'Enter':
        if (e.target.classList.contains('drag-handle')) {
          e.preventDefault();
          this.toggleKeyboardDragMode(item);
        }
        break;
    }
  }

  moveElement(element, target, position) {
    if (position === 'before') {
      target.parentNode.insertBefore(element, target);
    } else {
      target.parentNode.insertBefore(element, target.nextSibling);
    }
    
    this.updateActionOrder();
    this.announceOrderChange();
  }

  toggleKeyboardDragMode(item) {
    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…
    // è©³ç´°ã¯çœç•¥ï¼ˆå®Ÿè£…å¯èƒ½ï¼‰
  }

  updateActionOrder() {
    const items = this.container.querySelectorAll('.action-item-inline');
    const newOrder = Array.from(items).map((item, index) => ({
      id: item.dataset.actionId,
      order: index,
      element: item
    }));
    
    const event = new CustomEvent('actionOrderChanged', {
      detail: { 
        newOrder: newOrder,
        oldOrder: this.lastOrder || []
      }
    });
    
    this.container.dispatchEvent(event);
    this.lastOrder = newOrder;
  }

  announceOrderChange() {
    // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒªãƒ¼ãƒ€ãƒ¼ç”¨ã®é †åºå¤‰æ›´é€šçŸ¥
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.style.position = 'absolute';
    announcement.style.left = '-10000px';
    announcement.textContent = 'ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®é †åºãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸ';
    
    document.body.appendChild(announcement);
    setTimeout(() => document.body.removeChild(announcement), 1000);
  }

  dispatchDragEvent(type, element) {
    const event = new CustomEvent(type, {
      detail: {
        element: element,
        container: this.container,
        timestamp: Date.now()
      }
    });
    
    element.dispatchEvent(event);
  }

  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
    
    this.stopAutoScroll();
    this.container.removeEventListener('mousedown', this.handleMouseDown);
    document.removeEventListener('mousemove', this.handleMouseMove);
    document.removeEventListener('mouseup', this.handleMouseUp);
    // ãã®ä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚‚å‰Šé™¤
  }
}

// CSS ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾©
const dragDropStyles = `
@keyframes pulse {
  0% { opacity: 0.7; }
  50% { opacity: 0.9; }
  100% { opacity: 0.7; }
}

.drag-placeholder {
  animation: pulse 1s infinite;
}

.drag-ghost {
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.action-item-inline.dragging {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.drag-handle:active {
  cursor: grabbing;
}
`;

// ã‚¹ã‚¿ã‚¤ãƒ«ã‚·ãƒ¼ãƒˆã«è¿½åŠ 
if (!document.getElementById('drag-drop-styles')) {
  const styleSheet = document.createElement('style');
  styleSheet.id = 'drag-drop-styles';
  styleSheet.textContent = dragDropStyles;
  document.head.appendChild(styleSheet);
}
```

#### 11.2.3 ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã‚·ã‚¹ãƒ†ãƒ ï¼ˆå®Œå…¨å®Ÿè£…ï¼‰

ç¾åœ¨ã®åŸºæœ¬çš„ãªWebSocketå®Ÿè£…ã§ã¯ã€å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§å¿…è¦ãªæ©Ÿèƒ½ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼š

```javascript
class RealtimeSyncEngine {
  constructor(config) {
    this.wsUrl = config.wsUrl || 'ws://localhost:8086/sync';
    this.socket = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.syncInterval = null;
    this.pendingChanges = [];
    this.messageQueue = [];
    this.clientId = this.generateClientId();
    this.lastSyncTime = Date.now();
    this.syncState = 'disconnected'; // disconnected, connecting, connected, syncing
    this.conflictResolver = new ConflictResolver();
    this.changeBuffer = new ChangeBuffer();
    this.heartbeatInterval = null;
    this.listeners = new Map();
  }

  generateClientId() {
    return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  establishWebSocket() {
    this.syncState = 'connecting';
    this.notifyListeners('stateChanged', { state: this.syncState });
    
    try {
      this.socket = new WebSocket(this.wsUrl);
    } catch (error) {
      console.error('WebSocket creation failed:', error);
      this.handleConnectionError(error);
      return;
    }
    
    this.socket.onopen = () => {
      console.log('WebSocket connection established');
      this.syncState = 'connected';
      this.reconnectAttempts = 0;
      
      // èªè¨¼ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–
      this.authenticate();
      
      // ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆé–‹å§‹
      this.startHeartbeat();
      
      // ä¿ç•™ä¸­ã®å¤‰æ›´ã‚’é€ä¿¡
      this.flushPendingChanges();
      
      this.notifyListeners('connected', { clientId: this.clientId });
    };
    
    this.socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.handleServerMessage(data);
      } catch (error) {
        console.error('Failed to parse server message:', error);
      }
    };
    
    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      this.handleConnectionError(error);
    };
    
    this.socket.onclose = (event) => {
      console.log('WebSocket connection closed:', event.code, event.reason);
      this.syncState = 'disconnected';
      this.stopHeartbeat();
      
      if (event.code !== 1000) { // æ­£å¸¸ã‚¯ãƒ­ãƒ¼ã‚ºã§ãªã„å ´åˆ
        this.attemptReconnect();
      }
      
      this.notifyListeners('disconnected', { code: event.code, reason: event.reason });
    };
  }

  authenticate() {
    this.sendMessage({
      type: 'auth',
      clientId: this.clientId,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      capabilities: {
        compression: true,
        binaryFrames: true,
        encryption: window.crypto && window.crypto.subtle
      }
    });
  }

  startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.sendMessage({
          type: 'heartbeat',
          timestamp: Date.now()
        });
      }
    }, 30000); // 30ç§’é–“éš”
  }

  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }

  handleServerMessage(data) {
    switch(data.type) {
      case 'auth_success':
        this.handleAuthSuccess(data);
        break;
      
      case 'auth_failed':
        this.handleAuthFailed(data);
        break;
      
      case 'update':
        this.handleServerUpdate(data);
        break;
      
      case 'conflict':
        this.handleConflicts(data.conflicts);
        break;
      
      case 'sync':
        this.handleFullSync(data.state);
        break;
      
      case 'heartbeat_ack':
        this.handleHeartbeatAck(data);
        break;
      
      case 'client_connected':
      case 'client_disconnected':
        this.handleClientPresence(data);
        break;
      
      case 'error':
        this.handleServerError(data);
        break;
      
      default:
        console.warn('Unknown message type:', data.type);
    }
  }

  handleAuthSuccess(data) {
    this.sessionId = data.sessionId;
    this.serverTime = data.serverTime;
    this.timeDelta = data.serverTime - Date.now();
    
    // åˆæœŸçŠ¶æ…‹åŒæœŸ
    this.requestFullSync();
    
    this.notifyListeners('authenticated', { sessionId: this.sessionId });
  }

  handleAuthFailed(data) {
    console.error('Authentication failed:', data.reason);
    this.notifyListeners('authenticationFailed', data);
    
    // å†èªè¨¼è©¦è¡Œ
    setTimeout(() => {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        this.authenticate();
      }
    }, 5000);
  }

  syncChanges(changes) {
    // å¤‰æ›´ã‚’ãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ 
    this.changeBuffer.add(changes);
    
    // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ï¼ˆé€£ç¶šã™ã‚‹å¤‰æ›´ã‚’ã¾ã¨ã‚ã‚‹ï¼‰
    this.debouncedSync();
  }

  debouncedSync = this.debounce(() => {
    const bufferedChanges = this.changeBuffer.flush();
    if (bufferedChanges.length === 0) return;
    
    const changePacket = {
      type: 'update',
      clientId: this.clientId,
      sessionId: this.sessionId,
      timestamp: this.getServerTime(),
      changes: bufferedChanges,
      checksum: this.calculateChecksum(bufferedChanges)
    };
    
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.sendMessage(changePacket);
    } else {
      this.pendingChanges.push(changePacket);
    }
  }, 100);

  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  handleServerUpdate(data) {
    // é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if (this.isOwnChange(data)) {
      return; // è‡ªåˆ†ã®å¤‰æ›´ã¯ç„¡è¦–
    }
    
    // ãƒã‚§ãƒƒã‚¯ã‚µãƒ æ¤œè¨¼
    if (!this.verifyChecksum(data)) {
      console.warn('Checksum mismatch, requesting full sync');
      this.requestFullSync();
      return;
    }
    
    // å¤‰æ›´ã®é©ç”¨
    this.applyServerChanges(data.changes);
    
    // ç¢ºèªå¿œç­”
    this.sendMessage({
      type: 'update_ack',
      messageId: data.messageId,
      timestamp: this.getServerTime()
    });
    
    this.notifyListeners('updated', { changes: data.changes, source: 'server' });
  }

  isOwnChange(data) {
    return data.clientId === this.clientId;
  }

  verifyChecksum(data) {
    const calculatedChecksum = this.calculateChecksum(data.changes);
    return calculatedChecksum === data.checksum;
  }

  calculateChecksum(changes) {
    const changeString = JSON.stringify(changes);
    return this.simpleHash(changeString);
  }

  simpleHash(str) {
    let hash = 0;
    if (str.length === 0) return hash;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 32bit integer
    }
    return hash.toString(36);
  }

  applyServerChanges(changes) {
    changes.forEach(change => {
      switch(change.type) {
        case 'action_added':
          this.applyActionAdded(change);
          break;
        case 'action_updated':
          this.applyActionUpdated(change);
          break;
        case 'action_deleted':
          this.applyActionDeleted(change);
          break;
        case 'action_moved':
          this.applyActionMoved(change);
          break;
        case 'structure_added':
          this.applyStructureAdded(change);
          break;
        case 'structure_updated':
          this.applyStructureUpdated(change);
          break;
        default:
          console.warn('Unknown change type:', change.type);
      }
    });
  }

  applyActionAdded(change) {
    // DOMè¦ç´ ã®è¿½åŠ 
    const actionElement = this.createActionElement(change.action);
    const container = document.querySelector(change.containerId);
    if (container) {
      if (change.position !== undefined) {
        const children = container.children;
        if (change.position < children.length) {
          container.insertBefore(actionElement, children[change.position]);
        } else {
          container.appendChild(actionElement);
        }
      } else {
        container.appendChild(actionElement);
      }
    }
  }

  applyActionUpdated(change) {
    const actionElement = document.querySelector(`[data-action-id="${change.actionId}"]`);
    if (actionElement) {
      this.updateActionElement(actionElement, change.updates);
    }
  }

  applyActionDeleted(change) {
    const actionElement = document.querySelector(`[data-action-id="${change.actionId}"]`);
    if (actionElement) {
      actionElement.remove();
    }
  }

  applyActionMoved(change) {
    const actionElement = document.querySelector(`[data-action-id="${change.actionId}"]`);
    const targetContainer = document.querySelector(change.targetContainerId);
    
    if (actionElement && targetContainer) {
      const children = targetContainer.children;
      if (change.newPosition < children.length) {
        targetContainer.insertBefore(actionElement, children[change.newPosition]);
      } else {
        targetContainer.appendChild(actionElement);
      }
    }
  }

  handleConflicts(conflicts) {
    console.log('Handling conflicts:', conflicts);
    
    conflicts.forEach(conflict => {
      const resolution = this.conflictResolver.resolve(conflict);
      
      this.sendMessage({
        type: 'conflict_resolution',
        conflictId: conflict.id,
        resolution: resolution,
        timestamp: this.getServerTime()
      });
      
      // è§£æ±ºçµæœã‚’UIã«é©ç”¨
      this.applyConflictResolution(conflict, resolution);
    });
    
    this.notifyListeners('conflictsResolved', { conflicts, resolutions: conflicts.map(c => c.resolution) });
  }

  handleFullSync(serverState) {
    console.log('Performing full sync');
    this.syncState = 'syncing';
    
    // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    const currentState = this.getCurrentState();
    
    try {
      // ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ã‚’é©ç”¨
      this.applyFullState(serverState);
      
      this.lastSyncTime = Date.now();
      this.syncState = 'connected';
      
      this.notifyListeners('fullSyncComplete', { serverState, previousState: currentState });
      
    } catch (error) {
      console.error('Full sync failed:', error);
      
      // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
      this.applyFullState(currentState);
      
      this.notifyListeners('fullSyncFailed', { error, restoredState: currentState });
    }
  }

  handleClientPresence(data) {
    this.notifyListeners('clientPresence', {
      type: data.type,
      clientId: data.clientId,
      clientInfo: data.clientInfo
    });
  }

  handleServerError(data) {
    console.error('Server error:', data.error, data.details);
    
    if (data.fatal) {
      this.handleConnectionError(new Error(data.error));
    }
    
    this.notifyListeners('serverError', data);
  }

  sendMessage(message) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      message.messageId = this.generateMessageId();
      this.socket.send(JSON.stringify(message));
    } else {
      this.messageQueue.push(message);
    }
  }

  generateMessageId() {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  getServerTime() {
    return Date.now() + this.timeDelta;
  }

  attemptReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      this.notifyListeners('maxReconnectAttemptsReached', { attempts: this.reconnectAttempts });
      return;
    }
    
    this.reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    
    console.log(`Reconnection attempt ${this.reconnectAttempts} in ${delay}ms`);
    
    setTimeout(() => {
      if (this.syncState === 'disconnected') {
        this.establishWebSocket();
      }
    }, delay);
  }

  flushPendingChanges() {
    while (this.pendingChanges.length > 0) {
      const change = this.pendingChanges.shift();
      this.sendMessage(change);
    }
    
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      this.sendMessage(message);
    }
  }

  requestFullSync() {
    this.sendMessage({
      type: 'request_full_sync',
      lastSyncTime: this.lastSyncTime,
      timestamp: this.getServerTime()
    });
  }

  addEventListener(event, listener) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(listener);
  }

  removeEventListener(event, listener) {
    if (this.listeners.has(event)) {
      const listeners = this.listeners.get(event);
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  notifyListeners(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(listener => {
        try {
          listener(data);
        } catch (error) {
          console.error('Listener error:', error);
        }
      });
    }
  }

  startPeriodicSync(interval = 5000) {
    this.syncInterval = setInterval(() => {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.sendMessage({
          type: 'sync_request',
          timestamp: this.getServerTime()
        });
      }
    }, interval);
  }

  stopSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
    
    this.stopHeartbeat();
    
    if (this.socket) {
      this.socket.close(1000, 'Client disconnect');
    }
    
    this.syncState = 'disconnected';
  }

  getCurrentState() {
    // ç¾åœ¨ã®ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼çŠ¶æ…‹ã‚’å–å¾—
    const actions = Array.from(document.querySelectorAll('.action-item-inline')).map(el => {
      return {
        id: el.dataset.actionId,
        actorFrom: el.querySelector('.actor-select-inline:first-child').value,
        actorTo: el.querySelector('.actor-select-inline:last-child').value,
        message: el.querySelector('.message-input-inline').value,
        arrowType: el.querySelector('.arrow-type-inline').value,
        position: Array.from(el.parentNode.children).indexOf(el)
      };
    });
    
    return {
      actions: actions,
      timestamp: Date.now(),
      version: this.getStateVersion()
    };
  }

  applyFullState(state) {
    // UIã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆã—ã¦æ–°ã—ã„çŠ¶æ…‹ã‚’é©ç”¨
    const container = document.querySelector('.inline-editor');
    if (!container) return;
    
    // æ—¢å­˜ã®è¦ç´ ã‚’ã‚¯ãƒªã‚¢
    container.innerHTML = '';
    
    // æ–°ã—ã„çŠ¶æ…‹ã‚’é©ç”¨
    state.actions.forEach(action => {
      const actionElement = this.createActionElement(action);
      container.appendChild(actionElement);
    });
  }

  getStateVersion() {
    // çŠ¶æ…‹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã‚’ç”Ÿæˆï¼ˆå¤‰æ›´è¿½è·¡ç”¨ï¼‰
    return Date.now();
  }

  destroy() {
    this.stopSync();
    this.listeners.clear();
    this.pendingChanges = [];
    this.messageQueue = [];
  }
}

// è£œåŠ©ã‚¯ãƒ©ã‚¹ï¼šç«¶åˆè§£æ±º
class ConflictResolver {
  resolve(conflict) {
    switch (conflict.type) {
      case 'concurrent_edit':
        return this.resolveConcurrentEdit(conflict);
      case 'order_conflict':
        return this.resolveOrderConflict(conflict);
      case 'delete_edit_conflict':
        return this.resolveDeleteEditConflict(conflict);
      default:
        return this.defaultResolution(conflict);
    }
  }

  resolveConcurrentEdit(conflict) {
    // Last Write Wins + Mergeæˆ¦ç•¥
    if (conflict.clientTimestamp > conflict.serverTimestamp) {
      return {
        strategy: 'client_wins',
        result: conflict.clientChange
      };
    } else {
      return {
        strategy: 'server_wins',
        result: conflict.serverChange
      };
    }
  }

  resolveOrderConflict(conflict) {
    // ç§»å‹•æ“ä½œã®ç«¶åˆï¼šæœ€æ–°ã®æ“ä½œã‚’å„ªå…ˆ
    return {
      strategy: 'latest_wins',
      result: conflict.clientTimestamp > conflict.serverTimestamp ? 
              conflict.clientChange : conflict.serverChange
    };
  }

  resolveDeleteEditConflict(conflict) {
    // å‰Šé™¤ã¨ç·¨é›†ã®ç«¶åˆï¼šå‰Šé™¤ã‚’å„ªå…ˆ
    return {
      strategy: 'delete_wins',
      result: { type: 'delete', id: conflict.targetId }
    };
  }

  defaultResolution(conflict) {
    return {
      strategy: 'manual_required',
      result: null
    };
  }
}

// è£œåŠ©ã‚¯ãƒ©ã‚¹ï¼šå¤‰æ›´ãƒãƒƒãƒ•ã‚¡
class ChangeBuffer {
  constructor() {
    this.changes = [];
    this.maxSize = 100;
  }

  add(change) {
    this.changes.push({
      ...change,
      timestamp: Date.now(),
      id: this.generateChangeId()
    });

    // ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºåˆ¶é™
    if (this.changes.length > this.maxSize) {
      this.changes = this.changes.slice(-this.maxSize);
    }
  }

  flush() {
    const changes = [...this.changes];
    this.changes = [];
    return changes;
  }

  generateChangeId() {
    return `change_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

#### 11.2.4 è¤‡é›‘æ§‹é€ ã‚¨ãƒ‡ã‚£ã‚¿ï¼ˆå®Œå…¨å®Ÿè£…ï¼‰

ç¾åœ¨ã®åŸºæœ¬çš„ãªæ¡ä»¶åˆ†å²ãƒ»ãƒ«ãƒ¼ãƒ—ãƒ»ä¸¦è¡Œå‡¦ç†ã®å®Ÿè£…ã§ã¯ã€å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã§å¿…è¦ãªæ©Ÿèƒ½ãŒå¤§å¹…ã«ä¸è¶³ã—ã¦ã„ã¾ã™ï¼š

```javascript
class ComplexStructureEditor {
  constructor(container) {
    this.container = container;
    this.structures = new Map();
    this.idCounter = 0;
    this.clipboard = null;
    this.undoStack = [];
    this.redoStack = [];
    this.maxUndoSize = 50;
  }

  generateId() {
    return `struct_${++this.idCounter}_${Date.now()}`;
  }

  createStructure(type, config = {}) {
    const id = this.generateId();
    let structure;

    switch (type) {
      case 'conditional':
        structure = this.createConditionalStructure(id, config);
        break;
      case 'loop':
        structure = this.createLoopStructure(id, config);
        break;
      case 'parallel':
        structure = this.createParallelStructure(id, config);
        break;
      case 'try_catch':
        structure = this.createTryCatchStructure(id, config);
        break;
      case 'switch':
        structure = this.createSwitchStructure(id, config);
        break;
      default:
        throw new Error(`Unknown structure type: ${type}`);
    }

    this.structures.set(id, structure);
    this.saveState();
    return structure;
  }

  createConditionalStructure(id, config) {
    const condition = config.condition || '';
    const element = document.createElement('div');
    element.className = 'conditional-block';
    element.dataset.structureId = id;
    element.setAttribute('role', 'group');
    element.setAttribute('aria-label', `æ¡ä»¶åˆ†å²: ${condition}`);

    element.innerHTML = `
      <div class="conditional-header">
        <div class="header-controls">
          <span class="block-icon" aria-hidden="true">âš¡</span>
          <input type="text" 
                 class="condition-input" 
                 value="${this.escapeHtml(condition)}" 
                 placeholder="æ¡ä»¶ã‚’å…¥åŠ›ï¼ˆä¾‹ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒèªè¨¼æ¸ˆã¿ï¼‰"
                 aria-label="æ¡ä»¶">
          <div class="header-buttons">
            <button class="toggle-btn" 
                    aria-expanded="true" 
                    aria-controls="conditional-body-${id}"
                    title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ˜ã‚ŠãŸãŸã¿/å±•é–‹">â–¼</button>
            <button class="duplicate-btn" 
                    title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¤‡è£½"
                    aria-label="ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¤‡è£½">ğŸ“‹</button>
            <button class="delete-btn" 
                    title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤"
                    aria-label="ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤">ğŸ—‘ï¸</button>
          </div>
        </div>
        <div class="condition-info">
          <span class="condition-type">IF</span>
          <span class="condition-preview"></span>
        </div>
      </div>
      <div class="conditional-body" id="conditional-body-${id}">
        <div class="branch-container">
          <div class="branch true-branch">
            <div class="branch-header">
              <span class="branch-icon">âœ“</span>
              <span class="branch-label">TRUEåˆ†å²</span>
              <span class="action-count">0å€‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</span>
            </div>
            <div class="branch-content" 
                 data-branch="true" 
                 data-drop-zone="true"
                 role="group"
                 aria-label="TRUEåˆ†å²ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³">
              <div class="empty-state">
                <p>æ¡ä»¶ãŒTRUEã®å ´åˆã®å‡¦ç†ã‚’ã“ã“ã«è¿½åŠ </p>
                <button class="add-action-btn primary">+ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ </button>
              </div>
            </div>
          </div>
          <div class="branch false-branch">
            <div class="branch-header">
              <span class="branch-icon">âœ—</span>
              <span class="branch-label">FALSEåˆ†å²</span>
              <span class="action-count">0å€‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</span>
            </div>
            <div class="branch-content" 
                 data-branch="false" 
                 data-drop-zone="true"
                 role="group"
                 aria-label="FALSEåˆ†å²ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³">
              <div class="empty-state">
                <p>æ¡ä»¶ãŒFALSEã®å ´åˆã®å‡¦ç†ã‚’ã“ã“ã«è¿½åŠ </p>
                <button class="add-action-btn secondary">+ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ </button>
              </div>
            </div>
          </div>
        </div>
        <div class="branch-actions">
          <button class="add-elseif-btn">+ ELSE IF åˆ†å²è¿½åŠ </button>
        </div>
      </div>
    `;

    this.bindConditionalEvents(element, id);
    return { id, element, type: 'conditional', config };
  }

  bindConditionalEvents(element, id) {
    // æ¡ä»¶å…¥åŠ›ã®å‡¦ç†
    const conditionInput = element.querySelector('.condition-input');
    const conditionPreview = element.querySelector('.condition-preview');
    
    conditionInput.addEventListener('input', (e) => {
      const value = e.target.value;
      conditionPreview.textContent = value ? `: ${value}` : '';
      this.updateStructureConfig(id, { condition: value });
      this.notifyChange('condition_updated', { id, condition: value });
    });

    // æŠ˜ã‚ŠãŸãŸã¿æ©Ÿèƒ½
    const toggleBtn = element.querySelector('.toggle-btn');
    const body = element.querySelector('.conditional-body');
    
    toggleBtn.addEventListener('click', () => {
      const isExpanded = toggleBtn.getAttribute('aria-expanded') === 'true';
      toggleBtn.setAttribute('aria-expanded', !isExpanded);
      toggleBtn.textContent = isExpanded ? 'â–¶' : 'â–¼';
      body.style.display = isExpanded ? 'none' : 'block';
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      if (!isExpanded) {
        body.style.animation = 'expandBlock 0.3s ease-out';
      }
    });

    // è¤‡è£½æ©Ÿèƒ½
    const duplicateBtn = element.querySelector('.duplicate-btn');
    duplicateBtn.addEventListener('click', () => {
      this.duplicateStructure(id);
    });

    // å‰Šé™¤æ©Ÿèƒ½
    const deleteBtn = element.querySelector('.delete-btn');
    deleteBtn.addEventListener('click', () => {
      this.deleteStructure(id);
    });

    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ ãƒœã‚¿ãƒ³
    const addActionBtns = element.querySelectorAll('.add-action-btn');
    addActionBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const branch = e.target.closest('.branch-content').dataset.branch;
        this.addActionToBranch(id, branch);
      });
    });

    // ELSE IFè¿½åŠ 
    const addElseIfBtn = element.querySelector('.add-elseif-btn');
    addElseIfBtn.addEventListener('click', () => {
      this.addElseIfBranch(element, id);
    });

    // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³è¨­å®š
    this.setupDropZones(element);
  }

  addElseIfBranch(element, structureId) {
    const branchContainer = element.querySelector('.branch-container');
    const elseIfIndex = branchContainer.querySelectorAll('.elseif-branch').length + 1;
    
    const elseIfBranch = document.createElement('div');
    elseIfBranch.className = 'branch elseif-branch';
    elseIfBranch.innerHTML = `
      <div class="branch-header">
        <span class="branch-icon">ğŸ”</span>
        <input type="text" 
               class="elseif-condition" 
               placeholder="ELSE IF æ¡ä»¶"
               aria-label="ELSE IFæ¡ä»¶ ${elseIfIndex}">
        <button class="remove-elseif-btn" 
                title="ã“ã®åˆ†å²ã‚’å‰Šé™¤"
                aria-label="ELSE IFåˆ†å²ã‚’å‰Šé™¤">Ã—</button>
        <span class="action-count">0å€‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</span>
      </div>
      <div class="branch-content" 
           data-branch="elseif-${elseIfIndex}" 
           data-drop-zone="true"
           role="group"
           aria-label="ELSE IFåˆ†å² ${elseIfIndex}ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³">
        <div class="empty-state">
          <p>ELSE IFæ¡ä»¶ãŒTRUEã®å ´åˆã®å‡¦ç†ã‚’ã“ã“ã«è¿½åŠ </p>
          <button class="add-action-btn tertiary">+ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ </button>
        </div>
      </div>
    `;

    // FALSEåˆ†å²ã®å‰ã«æŒ¿å…¥
    const falseBranch = branchContainer.querySelector('.false-branch');
    branchContainer.insertBefore(elseIfBranch, falseBranch);

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰
    const removeBtn = elseIfBranch.querySelector('.remove-elseif-btn');
    removeBtn.addEventListener('click', () => {
      elseIfBranch.remove();
      this.updateActionCounts(element);
    });

    const addActionBtn = elseIfBranch.querySelector('.add-action-btn');
    addActionBtn.addEventListener('click', (e) => {
      const branch = e.target.closest('.branch-content').dataset.branch;
      this.addActionToBranch(structureId, branch);
    });

    this.setupDropZones(elseIfBranch);
    this.saveState();
  }

  createLoopStructure(id, config) {
    const condition = config.condition || '';
    const loopType = config.loopType || 'while';
    
    const element = document.createElement('div');
    element.className = 'loop-block';
    element.dataset.structureId = id;
    element.setAttribute('role', 'group');
    element.setAttribute('aria-label', `ãƒ«ãƒ¼ãƒ—: ${condition}`);

    element.innerHTML = `
      <div class="loop-header">
        <div class="header-controls">
          <span class="block-icon" aria-hidden="true">ğŸ”„</span>
          <select class="loop-type-select" aria-label="ãƒ«ãƒ¼ãƒ—ã®ç¨®é¡">
            <option value="while" ${loopType === 'while' ? 'selected' : ''}>WHILEï¼ˆæ¡ä»¶ãƒ«ãƒ¼ãƒ—ï¼‰</option>
            <option value="for" ${loopType === 'for' ? 'selected' : ''}>FORï¼ˆå›æ•°ãƒ«ãƒ¼ãƒ—ï¼‰</option>
            <option value="foreach" ${loopType === 'foreach' ? 'selected' : ''}>FOR EACHï¼ˆè¦ç´ ãƒ«ãƒ¼ãƒ—ï¼‰</option>
            <option value="do-while" ${loopType === 'do-while' ? 'selected' : ''}>DO-WHILEï¼ˆå¾Œåˆ¤å®šãƒ«ãƒ¼ãƒ—ï¼‰</option>
          </select>
          <input type="text" 
                 class="loop-condition" 
                 value="${this.escapeHtml(condition)}" 
                 placeholder="ãƒ«ãƒ¼ãƒ—æ¡ä»¶ã‚’å…¥åŠ›"
                 aria-label="ãƒ«ãƒ¼ãƒ—æ¡ä»¶">
          <div class="header-buttons">
            <button class="toggle-btn" 
                    aria-expanded="true" 
                    aria-controls="loop-body-${id}"
                    title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ˜ã‚ŠãŸãŸã¿/å±•é–‹">â–¼</button>
            <button class="duplicate-btn" title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¤‡è£½">ğŸ“‹</button>
            <button class="delete-btn" title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤">ğŸ—‘ï¸</button>
          </div>
        </div>
        <div class="loop-info">
          <span class="loop-type-indicator">${loopType.toUpperCase()}</span>
          <span class="loop-preview"></span>
        </div>
      </div>
      <div class="loop-body" id="loop-body-${id}">
        <div class="loop-content" 
             data-drop-zone="true"
             role="group"
             aria-label="ãƒ«ãƒ¼ãƒ—å†…ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³">
          <div class="empty-state">
            <p>ãƒ«ãƒ¼ãƒ—å†…ã§å®Ÿè¡Œã™ã‚‹å‡¦ç†ã‚’ã“ã“ã«è¿½åŠ </p>
            <button class="add-action-btn primary">+ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ </button>
          </div>
        </div>
        <div class="loop-controls">
          <div class="loop-options">
            <label class="checkbox-label">
              <input type="checkbox" class="break-condition">
              <span>ãƒ–ãƒ¬ãƒ¼ã‚¯æ¡ä»¶ã‚’è¨­å®š</span>
            </label>
            <input type="text" 
                   class="break-condition-input" 
                   placeholder="ãƒ–ãƒ¬ãƒ¼ã‚¯æ¡ä»¶"
                   style="display: none;"
                   aria-label="ãƒ–ãƒ¬ãƒ¼ã‚¯æ¡ä»¶">
          </div>
          <div class="loop-stats">
            <span class="action-count">0å€‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</span>
            <span class="estimated-iterations">æ¨å®šå®Ÿè¡Œå›æ•°: ä¸æ˜</span>
          </div>
        </div>
      </div>
    `;

    this.bindLoopEvents(element, id);
    return { id, element, type: 'loop', config };
  }

  bindLoopEvents(element, id) {
    // ãƒ«ãƒ¼ãƒ—ã‚¿ã‚¤ãƒ—å¤‰æ›´
    const typeSelect = element.querySelector('.loop-type-select');
    const typeIndicator = element.querySelector('.loop-type-indicator');
    const conditionInput = element.querySelector('.loop-condition');
    
    typeSelect.addEventListener('change', (e) => {
      const newType = e.target.value;
      typeIndicator.textContent = newType.toUpperCase();
      this.updateLoopPlaceholder(conditionInput, newType);
      this.updateStructureConfig(id, { loopType: newType });
      this.notifyChange('loop_type_changed', { id, loopType: newType });
    });

    // æ¡ä»¶å…¥åŠ›
    const conditionPreview = element.querySelector('.loop-preview');
    conditionInput.addEventListener('input', (e) => {
      const value = e.target.value;
      conditionPreview.textContent = value ? `: ${value}` : '';
      this.updateStructureConfig(id, { condition: value });
      this.estimateIterations(element, value, typeSelect.value);
    });

    // ãƒ–ãƒ¬ãƒ¼ã‚¯æ¡ä»¶
    const breakCheckbox = element.querySelector('.break-condition');
    const breakInput = element.querySelector('.break-condition-input');
    
    breakCheckbox.addEventListener('change', (e) => {
      breakInput.style.display = e.target.checked ? 'block' : 'none';
      if (!e.target.checked) {
        breakInput.value = '';
      }
    });

    // åŸºæœ¬çš„ãªã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæŠ˜ã‚ŠãŸãŸã¿ã€è¤‡è£½ã€å‰Šé™¤ï¼‰
    this.bindCommonEvents(element, id);

    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ 
    const addActionBtn = element.querySelector('.add-action-btn');
    addActionBtn.addEventListener('click', () => {
      this.addActionToLoop(id);
    });

    // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³è¨­å®š
    this.setupDropZones(element);
  }

  updateLoopPlaceholder(input, loopType) {
    const placeholders = {
      'while': 'ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹é™ã‚Š',
      'for': '10å›',
      'foreach': 'é…åˆ—ã®å„è¦ç´ ã«ã¤ã„ã¦',
      'do-while': 'æœ€ä½1å›ã€æ¡ä»¶ã‚’æº€ãŸã™é™ã‚Š'
    };
    
    input.placeholder = placeholders[loopType] || 'ãƒ«ãƒ¼ãƒ—æ¡ä»¶ã‚’å…¥åŠ›';
  }

  estimateIterations(element, condition, loopType) {
    const estimatedElement = element.querySelector('.estimated-iterations');
    let estimation = 'ä¸æ˜';
    
    if (loopType === 'for' && condition) {
      const numberMatch = condition.match(/(\d+)/);
      if (numberMatch) {
        estimation = `ç´„${numberMatch[1]}å›`;
      }
    } else if (loopType === 'foreach' && condition.includes('é…åˆ—')) {
      estimation = 'é…åˆ—ã‚µã‚¤ã‚ºã«ä¾å­˜';
    } else if (condition.includes('ç„¡é™') || condition.includes('å¸¸ã«')) {
      estimation = 'âš ï¸ ç„¡é™ãƒ«ãƒ¼ãƒ—ã®å¯èƒ½æ€§';
      estimatedElement.style.color = '#f44336';
    }
    
    estimatedElement.textContent = `æ¨å®šå®Ÿè¡Œå›æ•°: ${estimation}`;
  }

  createParallelStructure(id, config) {
    const threadCount = config.threadCount || 2;
    
    const element = document.createElement('div');
    element.className = 'parallel-block';
    element.dataset.structureId = id;
    element.setAttribute('role', 'group');
    element.setAttribute('aria-label', 'ä¸¦è¡Œå‡¦ç†');

    element.innerHTML = `
      <div class="parallel-header">
        <div class="header-controls">
          <span class="block-icon" aria-hidden="true">âš¡âš¡</span>
          <span class="block-title">ä¸¦è¡Œå‡¦ç†</span>
          <div class="thread-counter">
            <button class="thread-decrease" 
                    title="ã‚¹ãƒ¬ãƒƒãƒ‰æ•°ã‚’æ¸›ã‚‰ã™"
                    aria-label="ã‚¹ãƒ¬ãƒƒãƒ‰æ•°ã‚’æ¸›ã‚‰ã™">âˆ’</button>
            <span class="thread-count">${threadCount}</span>
            <button class="thread-increase" 
                    title="ã‚¹ãƒ¬ãƒƒãƒ‰æ•°ã‚’å¢—ã‚„ã™"
                    aria-label="ã‚¹ãƒ¬ãƒƒãƒ‰æ•°ã‚’å¢—ã‚„ã™">+</button>
          </div>
          <div class="header-buttons">
            <button class="toggle-btn" 
                    aria-expanded="true" 
                    aria-controls="parallel-body-${id}"
                    title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ˜ã‚ŠãŸãŸã¿/å±•é–‹">â–¼</button>
            <button class="duplicate-btn" title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¤‡è£½">ğŸ“‹</button>
            <button class="delete-btn" title="ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤">ğŸ—‘ï¸</button>
          </div>
        </div>
        <div class="parallel-info">
          <span class="execution-mode">ä¸¦è¡Œå®Ÿè¡Œ</span>
          <span class="sync-mode">éåŒæœŸ</span>
        </div>
      </div>
      <div class="parallel-body" id="parallel-body-${id}">
        <div class="parallel-tabs" role="tablist" aria-label="ä¸¦è¡Œå‡¦ç†ã®ã‚¹ãƒ¬ãƒƒãƒ‰">
        </div>
        <div class="parallel-contents">
        </div>
        <div class="parallel-controls">
          <div class="sync-options">
            <label class="radio-label">
              <input type="radio" name="sync-mode-${id}" value="async" checked>
              <span>éåŒæœŸå®Ÿè¡Œï¼ˆä¸¦è¡Œï¼‰</span>
            </label>
            <label class="radio-label">
              <input type="radio" name="sync-mode-${id}" value="sync">
              <span>åŒæœŸå®Ÿè¡Œï¼ˆé †æ¬¡ï¼‰</span>
            </label>
          </div>
          <div class="join-options">
            <label class="checkbox-label">
              <input type="checkbox" class="wait-all">
              <span>å…¨ã‚¹ãƒ¬ãƒƒãƒ‰å®Œäº†ã‚’å¾…æ©Ÿ</span>
            </label>
          </div>
        </div>
      </div>
    `;

    this.bindParallelEvents(element, id);
    
    // åˆæœŸã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆ
    for (let i = 0; i < threadCount; i++) {
      this.addThread(element, i);
    }
    
    return { id, element, type: 'parallel', config };
  }

  bindParallelEvents(element, id) {
    // ã‚¹ãƒ¬ãƒƒãƒ‰æ•°åˆ¶å¾¡
    const decreaseBtn = element.querySelector('.thread-decrease');
    const increaseBtn = element.querySelector('.thread-increase');
    const countDisplay = element.querySelector('.thread-count');
    
    decreaseBtn.addEventListener('click', () => {
      const currentCount = parseInt(countDisplay.textContent);
      if (currentCount > 1) {
        this.removeThread(element, currentCount - 1);
        countDisplay.textContent = currentCount - 1;
      }
    });
    
    increaseBtn.addEventListener('click', () => {
      const currentCount = parseInt(countDisplay.textContent);
      if (currentCount < 10) { // æœ€å¤§10ã‚¹ãƒ¬ãƒƒãƒ‰
        this.addThread(element, currentCount);
        countDisplay.textContent = currentCount + 1;
      }
    });

    // åŒæœŸãƒ¢ãƒ¼ãƒ‰å¤‰æ›´
    const syncRadios = element.querySelectorAll('input[name^="sync-mode"]');
    const syncModeDisplay = element.querySelector('.sync-mode');
    
    syncRadios.forEach(radio => {
      radio.addEventListener('change', (e) => {
        syncModeDisplay.textContent = e.target.value === 'async' ? 'éåŒæœŸ' : 'åŒæœŸ';
        this.updateStructureConfig(id, { syncMode: e.target.value });
      });
    });

    // åŸºæœ¬çš„ãªã‚¤ãƒ™ãƒ³ãƒˆ
    this.bindCommonEvents(element, id);
  }

  addThread(parallelElement, index) {
    const tabContainer = parallelElement.querySelector('.parallel-tabs');
    const contentContainer = parallelElement.querySelector('.parallel-contents');
    
    // ã‚¿ãƒ–ä½œæˆ
    const tab = document.createElement('button');
    tab.className = 'thread-tab';
    tab.dataset.threadIndex = index;
    tab.setAttribute('role', 'tab');
    tab.setAttribute('aria-controls', `thread-content-${index}`);
    tab.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
    tab.innerHTML = `
      <span class="thread-icon">ğŸ§µ</span>
      <span class="thread-name">ã‚¹ãƒ¬ãƒƒãƒ‰${index + 1}</span>
      <span class="action-count">0</span>
      ${index > 0 ? '<button class="remove-thread-btn" title="ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’å‰Šé™¤">Ã—</button>' : ''}
    `;
    
    // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆ
    const content = document.createElement('div');
    content.className = 'thread-content';
    content.id = `thread-content-${index}`;
    content.dataset.threadIndex = index;
    content.setAttribute('role', 'tabpanel');
    content.setAttribute('aria-labelledby', `thread-tab-${index}`);
    content.innerHTML = `
      <div class="thread-header">
        <input type="text" 
               class="thread-name-input" 
               value="ã‚¹ãƒ¬ãƒƒãƒ‰${index + 1}"
               placeholder="ã‚¹ãƒ¬ãƒƒãƒ‰å"
               aria-label="ã‚¹ãƒ¬ãƒƒãƒ‰å">
        <select class="thread-priority" aria-label="ã‚¹ãƒ¬ãƒƒãƒ‰å„ªå…ˆåº¦">
          <option value="normal">é€šå¸¸å„ªå…ˆåº¦</option>
          <option value="high">é«˜å„ªå…ˆåº¦</option>
          <option value="low">ä½å„ªå…ˆåº¦</option>
        </select>
      </div>
      <div class="thread-actions" 
           data-drop-zone="true"
           role="group"
           aria-label="ã‚¹ãƒ¬ãƒƒãƒ‰${index + 1}ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³">
        <div class="empty-state">
          <p>ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã™ã‚‹å‡¦ç†ã‚’ã“ã“ã«è¿½åŠ </p>
          <button class="add-action-btn primary">+ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ </button>
        </div>
      </div>
      <div class="thread-stats">
        <span class="estimated-time">æ¨å®šå®Ÿè¡Œæ™‚é–“: ä¸æ˜</span>
        <span class="dependencies">ä¾å­˜é–¢ä¿‚: ãªã—</span>
      </div>
    `;
    
    // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆã‚¤ãƒ™ãƒ³ãƒˆ
    tab.addEventListener('click', (e) => {
      if (!e.target.classList.contains('remove-thread-btn')) {
        this.switchThread(parallelElement, index);
      }
    });
    
    // ã‚¹ãƒ¬ãƒƒãƒ‰å‰Šé™¤ã‚¤ãƒ™ãƒ³ãƒˆ
    const removeBtn = tab.querySelector('.remove-thread-btn');
    if (removeBtn) {
      removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.removeThread(parallelElement, index);
      });
    }
    
    // ã‚¹ãƒ¬ãƒƒãƒ‰åå¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
    const nameInput = content.querySelector('.thread-name-input');
    nameInput.addEventListener('input', (e) => {
      tab.querySelector('.thread-name').textContent = e.target.value;
    });
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ ã‚¤ãƒ™ãƒ³ãƒˆ
    const addActionBtn = content.querySelector('.add-action-btn');
    addActionBtn.addEventListener('click', () => {
      this.addActionToThread(content.querySelector('.thread-actions'));
    });
    
    tabContainer.appendChild(tab);
    contentContainer.appendChild(content);
    
    // æœ€åˆã®ã‚¿ãƒ–ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
    if (index === 0) {
      tab.classList.add('active');
      content.classList.add('active');
    }
    
    // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³è¨­å®š
    this.setupDropZones(content);
  }

  switchThread(parallelElement, index) {
    // ã™ã¹ã¦ã®ã‚¿ãƒ–ã¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
    parallelElement.querySelectorAll('.thread-tab').forEach(tab => {
      tab.classList.remove('active');
      tab.setAttribute('aria-selected', 'false');
    });
    
    parallelElement.querySelectorAll('.thread-content').forEach(content => {
      content.classList.remove('active');
    });
    
    // é¸æŠã•ã‚ŒãŸã‚¿ãƒ–ã¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
    const selectedTab = parallelElement.querySelector(`.thread-tab[data-thread-index="${index}"]`);
    const selectedContent = parallelElement.querySelector(`.thread-content[data-thread-index="${index}"]`);
    
    if (selectedTab && selectedContent) {
      selectedTab.classList.add('active');
      selectedTab.setAttribute('aria-selected', 'true');
      selectedContent.classList.add('active');
    }
  }

  removeThread(parallelElement, index) {
    const tab = parallelElement.querySelector(`.thread-tab[data-thread-index="${index}"]`);
    const content = parallelElement.querySelector(`.thread-content[data-thread-index="${index}"]`);
    
    if (tab && content) {
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã§å‰Šé™¤
      tab.style.opacity = '0';
      content.style.opacity = '0';
      
      setTimeout(() => {
        tab.remove();
        content.remove();
        this.reindexThreads(parallelElement);
      }, 200);
    }
    
    this.saveState();
  }

  reindexThreads(parallelElement) {
    const tabs = parallelElement.querySelectorAll('.thread-tab');
    const contents = parallelElement.querySelectorAll('.thread-content');
    
    tabs.forEach((tab, index) => {
      tab.dataset.threadIndex = index;
      if (!tab.querySelector('.thread-name-input').value.includes('ã‚«ã‚¹ã‚¿ãƒ ')) {
        tab.querySelector('.thread-name').textContent = `ã‚¹ãƒ¬ãƒƒãƒ‰${index + 1}`;
      }
    });
    
    contents.forEach((content, index) => {
      content.dataset.threadIndex = index;
      content.id = `thread-content-${index}`;
    });
    
    // æœ€åˆã®ã‚¿ãƒ–ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
    if (tabs.length > 0) {
      this.switchThread(parallelElement, 0);
    }
  }

  // ãã®ä»–ã®é«˜åº¦ãªæ§‹é€ ï¼ˆTry-Catchã€Switchï¼‰ã®å®Ÿè£…ã‚‚åŒæ§˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ä½œæˆ
  createTryCatchStructure(id, config) {
    // Try-Catchæ§‹é€ ã®å®Œå…¨å®Ÿè£…
    // è©³ç´°ã¯çœç•¥ï¼ˆä¸Šè¨˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã£ã¦å®Ÿè£…ï¼‰
  }

  createSwitchStructure(id, config) {
    // Switchæ§‹é€ ã®å®Œå…¨å®Ÿè£…
    // è©³ç´°ã¯çœç•¥ï¼ˆä¸Šè¨˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã£ã¦å®Ÿè£…ï¼‰
  }

  // å…±é€šã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰
  bindCommonEvents(element, id) {
    const toggleBtn = element.querySelector('.toggle-btn');
    const body = element.querySelector('[id$="-body"]');
    
    if (toggleBtn && body) {
      toggleBtn.addEventListener('click', () => {
        const isExpanded = toggleBtn.getAttribute('aria-expanded') === 'true';
        toggleBtn.setAttribute('aria-expanded', !isExpanded);
        toggleBtn.textContent = isExpanded ? 'â–¶' : 'â–¼';
        
        if (isExpanded) {
          body.style.height = body.scrollHeight + 'px';
          setTimeout(() => {
            body.style.height = '0';
            body.style.overflow = 'hidden';
          }, 10);
        } else {
          body.style.height = 'auto';
          const height = body.scrollHeight;
          body.style.height = '0';
          body.style.overflow = 'hidden';
          setTimeout(() => {
            body.style.height = height + 'px';
            setTimeout(() => {
              body.style.height = 'auto';
              body.style.overflow = 'visible';
            }, 300);
          }, 10);
        }
      });
    }

    const duplicateBtn = element.querySelector('.duplicate-btn');
    if (duplicateBtn) {
      duplicateBtn.addEventListener('click', () => {
        this.duplicateStructure(id);
      });
    }

    const deleteBtn = element.querySelector('.delete-btn');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', () => {
        this.deleteStructure(id);
      });
    }
  }

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  updateStructureConfig(id, updates) {
    const structure = this.structures.get(id);
    if (structure) {
      structure.config = { ...structure.config, ...updates };
    }
  }

  notifyChange(type, data) {
    const event = new CustomEvent('structureChanged', {
      detail: { type, ...data }
    });
    this.container.dispatchEvent(event);
  }

  saveState() {
    const state = this.getCurrentState();
    this.undoStack.push(state);
    
    if (this.undoStack.length > this.maxUndoSize) {
      this.undoStack.shift();
    }
    
    this.redoStack = []; // æ–°ã—ã„æ“ä½œã§redoã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚¯ãƒªã‚¢
  }

  getCurrentState() {
    return {
      structures: new Map(this.structures),
      timestamp: Date.now()
    };
  }

  setupDropZones(element) {
    // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½ã®è©³ç´°å®Ÿè£…
    // æ—¢ã«å®Ÿè£…æ¸ˆã¿ã®DragDropManagerã¨é€£æº
  }
}
```

### 11.3 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®å®Œå…¨å®Ÿè£…

æ™‚é–“çŸ­ç¸®1/5é”æˆã®ãŸã‚ã®æ ¸å¿ƒå®Ÿè£…ï¼š

```javascript
class PerformanceOptimizer {
  constructor() {
    this.cache = new Map();
    this.templateLibrary = new TemplateLibrary();
    this.autoComplete = new AutoCompleteEngine();
    this.presetManager = new PresetManager();
    this.smartSuggestions = new SmartSuggestionsEngine();
  }

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ©Ÿèƒ½ï¼ˆé–‹ç™ºæ™‚é–“ã‚’80%çŸ­ç¸®ï¼‰
  applyTemplate(templateName) {
    const template = this.templateLibrary.get(templateName);
    if (!template) return null;

    const instance = this.createTemplateInstance(template);
    this.notifyTemplateUsage(templateName);
    return instance;
  }

  createTemplateInstance(template) {
    return {
      id: `template_${Date.now()}`,
      structure: this.cloneStructure(template.structure),
      metadata: {
        ...template.metadata,
        created: Date.now(),
        isTemplate: true
      }
    };
  }

  // è‡ªå‹•è£œå®Œï¼ˆå…¥åŠ›æ™‚é–“ã‚’60%çŸ­ç¸®ï¼‰
  getSuggestions(input, context = {}) {
    const cacheKey = `${input}_${JSON.stringify(context)}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const suggestions = this.autoComplete.suggest(input, context);
    this.cache.set(cacheKey, suggestions);
    
    return suggestions;
  }

  // ãƒ—ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ï¼ˆç¹°ã‚Šè¿”ã—ä½œæ¥­ã‚’90%å‰Šæ¸›ï¼‰
  getPresets(category) {
    return this.presetManager.getByCategory(category);
  }

  applyPreset(presetId, customizations = {}) {
    const preset = this.presetManager.get(presetId);
    if (!preset) return null;

    return this.presetManager.apply(preset, customizations);
  }

  // ã‚¹ãƒãƒ¼ãƒˆææ¡ˆï¼ˆå­¦ç¿’æ©Ÿèƒ½ã§åŠ¹ç‡ã‚’å‘ä¸Šï¼‰
  getSmartSuggestions(currentContext) {
    return this.smartSuggestions.analyze(currentContext);
  }

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ€é©åŒ–
  getCachedResult(key) {
    return this.cache.get(key);
  }

  invalidateCache(pattern) {
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
      }
    }
  }
}

// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒª
class TemplateLibrary {
  constructor() {
    this.templates = new Map();
    this.categories = new Map();
    this.initializeBuiltinTemplates();
  }

  initializeBuiltinTemplates() {
    // ECæ¥­å‹™ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
    this.register('ecommerce_order_flow', {
      name: 'ECã‚µã‚¤ãƒˆæ³¨æ–‡ãƒ•ãƒ­ãƒ¼',
      category: 'ecommerce',
      description: 'ä¸€èˆ¬çš„ãªECã‚µã‚¤ãƒˆã®æ³¨æ–‡å‡¦ç†ãƒ•ãƒ­ãƒ¼',
      structure: this.createOrderFlowStructure(),
      estimatedTime: '5åˆ†', // é€šå¸¸30åˆ†â†’5åˆ†
      complexity: 'medium'
    });

    // APIèªè¨¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
    this.register('api_authentication', {
      name: 'APIèªè¨¼ãƒ•ãƒ­ãƒ¼',
      category: 'api',
      description: 'JWTèªè¨¼ã‚’å«ã‚€APIèªè¨¼ãƒ•ãƒ­ãƒ¼',
      structure: this.createAuthFlowStructure(),
      estimatedTime: '3åˆ†', // é€šå¸¸20åˆ†â†’3åˆ†
      complexity: 'low'
    });

    // ãƒãƒƒãƒå‡¦ç†ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
    this.register('batch_processing', {
      name: 'ãƒãƒƒãƒå‡¦ç†ãƒ•ãƒ­ãƒ¼',
      category: 'batch',
      description: 'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å‡¦ç†ã‚’å«ã‚€ãƒãƒƒãƒãƒ•ãƒ­ãƒ¼',
      structure: this.createBatchFlowStructure(),
      estimatedTime: '8åˆ†', // é€šå¸¸40åˆ†â†’8åˆ†
      complexity: 'high'
    });
  }

  createOrderFlowStructure() {
    return {
      steps: [
        { type: 'action', from: 'User', to: 'WebApp', message: 'å•†å“ã‚’ã‚«ãƒ¼ãƒˆã«è¿½åŠ ' },
        { type: 'conditional', condition: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿',
          trueBranch: [
            { type: 'action', from: 'WebApp', to: 'PaymentAPI', message: 'æ±ºæ¸ˆå‡¦ç†è¦æ±‚' }
          ],
          falseBranch: [
            { type: 'action', from: 'WebApp', to: 'User', message: 'ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢è¡¨ç¤º' }
          ]
        }
      ]
    };
  }

  createAuthFlowStructure() {
    return {
      steps: [
        { type: 'action', from: 'Client', to: 'AuthServer', message: 'ãƒ­ã‚°ã‚¤ãƒ³è¦æ±‚' },
        { type: 'conditional', condition: 'èªè¨¼æƒ…å ±ãŒæ­£ç¢º',
          trueBranch: [
            { type: 'action', from: 'AuthServer', to: 'Client', message: 'JWTãƒˆãƒ¼ã‚¯ãƒ³ç™ºè¡Œ' }
          ],
          falseBranch: [
            { type: 'action', from: 'AuthServer', to: 'Client', message: 'èªè¨¼ã‚¨ãƒ©ãƒ¼å¿œç­”' }
          ]
        }
      ]
    };
  }

  register(id, template) {
    this.templates.set(id, template);
    
    if (!this.categories.has(template.category)) {
      this.categories.set(template.category, []);
    }
    this.categories.get(template.category).push(id);
  }

  get(id) {
    return this.templates.get(id);
  }

  getByCategory(category) {
    const templateIds = this.categories.get(category) || [];
    return templateIds.map(id => this.templates.get(id));
  }
}

// è‡ªå‹•è£œå®Œã‚¨ãƒ³ã‚¸ãƒ³
class AutoCompleteEngine {
  constructor() {
    this.patterns = new Map();
    this.frequency = new Map();
    this.initializePatterns();
  }

  initializePatterns() {
    // ã‚ˆãä½¿ç”¨ã•ã‚Œã‚‹å‹•è©ãƒ‘ã‚¿ãƒ¼ãƒ³
    this.patterns.set('request', [
      'ãƒ­ã‚°ã‚¤ãƒ³è¦æ±‚', 'ãƒ‡ãƒ¼ã‚¿å–å¾—è¦æ±‚', 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰è¦æ±‚',
      'æ±ºæ¸ˆå‡¦ç†è¦æ±‚', 'ãƒ¡ãƒ¼ãƒ«é€ä¿¡è¦æ±‚', 'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¦æ±‚'
    ]);

    this.patterns.set('response', [
      'ãƒ­ã‚°ã‚¤ãƒ³å¿œç­”', 'ãƒ‡ãƒ¼ã‚¿å¿œç­”', 'ã‚¨ãƒ©ãƒ¼å¿œç­”',
      'å‡¦ç†å®Œäº†å¿œç­”', 'ç¢ºèªå¿œç­”', 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¿œç­”'
    ]);

    this.patterns.set('process', [
      'ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼å‡¦ç†', 'ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›å‡¦ç†', 'ãƒ¡ãƒ¼ãƒ«é€ä¿¡å‡¦ç†',
      'æ±ºæ¸ˆå‡¦ç†', 'ãƒ­ã‚°å‡ºåŠ›å‡¦ç†', 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°å‡¦ç†'
    ]);

    // ã‚¢ã‚¯ã‚¿ãƒ¼åãƒ‘ã‚¿ãƒ¼ãƒ³
    this.patterns.set('actors', [
      'User', 'System', 'Database', 'API', 'Server',
      'PaymentGateway', 'EmailService', 'FileStorage',
      'CacheServer', 'LoadBalancer', 'SecurityService'
    ]);

    // æ¡ä»¶ãƒ‘ã‚¿ãƒ¼ãƒ³
    this.patterns.set('conditions', [
      'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿', 'ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹', 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒåˆ¶é™å†…',
      'å‡¦ç†ãŒæˆåŠŸ', 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ', 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç™ºç”Ÿ',
      'æ¨©é™ãƒã‚§ãƒƒã‚¯é€šé', 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æˆåŠŸ'
    ]);
  }

  suggest(input, context = {}) {
    const suggestions = [];
    const lowerInput = input.toLowerCase();

    // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ææ¡ˆ
    for (const [category, patterns] of this.patterns) {
      const matches = patterns.filter(pattern => 
        pattern.toLowerCase().includes(lowerInput)
      );
      
      suggestions.push(...matches.map(match => ({
        text: match,
        category: category,
        confidence: this.calculateConfidence(input, match),
        type: 'pattern'
      })));
    }

    // é »åº¦ãƒ™ãƒ¼ã‚¹ææ¡ˆ
    const frequentSuggestions = this.getFrequentSuggestions(input);
    suggestions.push(...frequentSuggestions);

    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ææ¡ˆ
    const contextSuggestions = this.getContextSuggestions(input, context);
    suggestions.push(...contextSuggestions);

    // ä¿¡é ¼åº¦é †ã«ã‚½ãƒ¼ãƒˆ
    return suggestions
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 10); // ä¸Šä½10ä»¶
  }

  calculateConfidence(input, suggestion) {
    const inputLen = input.length;
    const suggestionLen = suggestion.length;
    
    if (inputLen === 0) return 0;
    
    // å®Œå…¨ä¸€è‡´
    if (input === suggestion) return 1.0;
    
    // å‰æ–¹ä¸€è‡´
    if (suggestion.startsWith(input)) return 0.9;
    
    // éƒ¨åˆ†ä¸€è‡´
    if (suggestion.includes(input)) return 0.7;
    
    // Levenshteinè·é›¢ãƒ™ãƒ¼ã‚¹
    const distance = this.levenshteinDistance(input, suggestion);
    return Math.max(0, 1 - (distance / Math.max(inputLen, suggestionLen)));
  }

  levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }

  recordUsage(suggestion) {
    const current = this.frequency.get(suggestion) || 0;
    this.frequency.set(suggestion, current + 1);
  }

  getFrequentSuggestions(input) {
    const suggestions = [];
    
    for (const [text, frequency] of this.frequency) {
      if (text.toLowerCase().includes(input.toLowerCase())) {
        suggestions.push({
          text: text,
          category: 'frequent',
          confidence: Math.min(0.8, frequency / 100), // ä½¿ç”¨é »åº¦ã‚’ä¿¡é ¼åº¦ã«å¤‰æ›
          type: 'frequent'
        });
      }
    }
    
    return suggestions;
  }

  getContextSuggestions(input, context) {
    const suggestions = [];
    
    // å‰ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«åŸºã¥ãææ¡ˆ
    if (context.previousAction) {
      const related = this.getRelatedActions(context.previousAction);
      suggestions.push(...related.map(action => ({
        text: action,
        category: 'contextual',
        confidence: 0.75,
        type: 'contextual'
      })));
    }
    
    // ç¾åœ¨ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã«åŸºã¥ãææ¡ˆ
    if (context.currentActor) {
      const actorActions = this.getActorActions(context.currentActor);
      suggestions.push(...actorActions.map(action => ({
        text: action,
        category: 'actor-based',
        confidence: 0.7,
        type: 'actor-based'
      })));
    }
    
    return suggestions;
  }

  getRelatedActions(previousAction) {
    const relations = {
      'ãƒ­ã‚°ã‚¤ãƒ³è¦æ±‚': ['èªè¨¼å‡¦ç†', 'ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ', 'ãƒ­ã‚°ã‚¤ãƒ³å¿œç­”'],
      'ãƒ‡ãƒ¼ã‚¿å–å¾—è¦æ±‚': ['ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œç´¢', 'ãƒ‡ãƒ¼ã‚¿å¿œç­”', 'ã‚¨ãƒ©ãƒ¼å‡¦ç†'],
      'ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰': ['ãƒ•ã‚¡ã‚¤ãƒ«æ¤œè¨¼', 'ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä¿å­˜', 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†']
    };
    
    return relations[previousAction] || [];
  }

  getActorActions(actor) {
    const actorActions = {
      'User': ['ãƒ­ã‚°ã‚¤ãƒ³', 'ãƒ‡ãƒ¼ã‚¿å…¥åŠ›', 'ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ', 'é€ä¿¡'],
      'System': ['æ¤œè¨¼å‡¦ç†', 'ãƒ‡ãƒ¼ã‚¿å‡¦ç†', 'å¿œç­”ç”Ÿæˆ', 'ãƒ­ã‚°å‡ºåŠ›'],
      'Database': ['ãƒ‡ãƒ¼ã‚¿æ¤œç´¢', 'ãƒ‡ãƒ¼ã‚¿æ›´æ–°', 'ãƒ‡ãƒ¼ã‚¿å‰Šé™¤', 'ãƒ‡ãƒ¼ã‚¿æŒ¿å…¥'],
      'API': ['ãƒªã‚¯ã‚¨ã‚¹ãƒˆå—ä¿¡', 'ãƒ‡ãƒ¼ã‚¿å¤‰æ›', 'å¤–éƒ¨APIå‘¼ã³å‡ºã—', 'å¿œç­”è¿”å´']
    };
    
    return actorActions[actor] || [];
  }
}
```

---

## 12. ç§»è¡Œã¨ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨ˆç”»

### 12.1 æ®µéšçš„å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

æœ¬å®Ÿè£…ã¯ä¾¡å€¤ææ¡ˆã®å®Ÿç¾å¯èƒ½æ€§è©•ä¾¡ã®çµæœã‚’å—ã‘ã¦ã€æ®µéšçš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æ¡ç”¨ã—ã¾ã™ï¼š

#### Phase 1: åŸºç¤æ©Ÿèƒ½å®Ÿè£…ï¼ˆ0-2é€±ï¼‰
- **ç›®æ¨™**: åŸºæœ¬å®Ÿç¾åº¦ã‚’20%â†’50%ã«å‘ä¸Š
- **å®Ÿè£…ç¯„å›²**:
  - PlantUMLå¤‰æ›ã‚¨ãƒ³ã‚¸ãƒ³ã®åŸºæœ¬æ©Ÿèƒ½
  - ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®åŸºæœ¬å®Ÿè£…
  - ç°¡å˜ãªæ¡ä»¶åˆ†å²ã‚¨ãƒ‡ã‚£ã‚¿
- **æˆåŠŸæŒ‡æ¨™**: åŸºæœ¬çš„ãªæ—¥æœ¬èªâ†’PlantUMLå¤‰æ›ãŒå‹•ä½œ

#### Phase 2: æ€§èƒ½æœ€é©åŒ–ï¼ˆ2-4é€±ï¼‰
- **ç›®æ¨™**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å®Ÿç¾åº¦ã‚’15%â†’60%ã«å‘ä¸Š
- **å®Ÿè£…ç¯„å›²**:
  - ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ§‹ç¯‰
  - è‡ªå‹•è£œå®Œã‚¨ãƒ³ã‚¸ãƒ³ã®å®Ÿè£…
  - åŸºæœ¬çš„ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½
- **æˆåŠŸæŒ‡æ¨™**: å…¸å‹çš„ãªä½œæ¥­æ™‚é–“ãŒ30åˆ†â†’15åˆ†ã«çŸ­ç¸®

#### Phase 3: é«˜åº¦æ©Ÿèƒ½ï¼ˆ4-6é€±ï¼‰
- **ç›®æ¨™**: è¤‡é›‘æ€§å¯¾å¿œã‚’10%â†’70%ã«å‘ä¸Š
- **å®Ÿè£…ç¯„å›²**:
  - å®Œå…¨ãªè¤‡é›‘æ§‹é€ ã‚¨ãƒ‡ã‚£ã‚¿
  - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã‚·ã‚¹ãƒ†ãƒ 
  - ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œã¨ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£
- **æˆåŠŸæŒ‡æ¨™**: è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ä½œæˆãŒå¯èƒ½

#### Phase 4: çµ±åˆã¨ãƒ†ã‚¹ãƒˆï¼ˆ6-8é€±ï¼‰
- **ç›®æ¨™**: ç·åˆå®Ÿç¾åº¦ã‚’80%ä»¥ä¸Šã«åˆ°é”
- **å®Ÿè£…ç¯„å›²**:
  - E2Eãƒ†ã‚¹ãƒˆã®å®Ÿæ–½
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
  - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»
- **æˆåŠŸæŒ‡æ¨™**: ã™ã¹ã¦ã®ä¾¡å€¤ææ¡ˆãŒå®Ÿè¨¼å¯èƒ½

### 12.2 ãƒªã‚¹ã‚¯è»½æ¸›æˆ¦ç•¥

#### é«˜ãƒªã‚¹ã‚¯é …ç›®ã®å¯¾å¿œ

1. **æ—¥æœ¬èªè§£æã®ç²¾åº¦å•é¡Œ**
   - **ãƒªã‚¹ã‚¯**: NLPå‡¦ç†ã®è¤‡é›‘æ€§
   - **è»½æ¸›ç­–**: æ®µéšçš„ãƒ‘ã‚¿ãƒ¼ãƒ³è¿½åŠ ã€æ©Ÿæ¢°å­¦ç¿’ã®å¾Œä»˜ã‘å®Ÿè£…
   - **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**: æ‰‹å‹•ã§ã®æ§‹é€ ä¿®æ­£æ©Ÿèƒ½

2. **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã®è¤‡é›‘æ€§**
   - **ãƒªã‚¹ã‚¯**: ç«¶åˆå‡¦ç†ã¨ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§
   - **è»½æ¸›ç­–**: ç°¡å˜ãªç«¶åˆè§£æ±ºæˆ¦ç•¥ã‹ã‚‰é–‹å§‹
   - **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ã®å……å®Ÿ

3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™ã®æœªé”**
   - **ãƒªã‚¹ã‚¯**: 80%ã®æ™‚é–“çŸ­ç¸®ãŒå›°é›£
   - **è»½æ¸›ç­–**: æ®µéšçš„ãªæœ€é©åŒ–ã¨æ¸¬å®š
   - **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**: ç›®æ¨™å€¤ã®æ®µéšçš„èª¿æ•´

### 12.3 ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨ˆç”»

#### ç·Šæ€¥æ™‚å¯¾å¿œæ‰‹é †

1. **å³åº§ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯**ï¼ˆ1æ™‚é–“ä»¥å†…ï¼‰
   - ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã«å¾©æ—§
   - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çŠ¶æ…‹ã®å·»ãæˆ»ã—
   - DNSåˆ‡ã‚Šæ›¿ãˆã«ã‚ˆã‚‹ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯åˆ¶å¾¡

2. **æ®µéšçš„ãªæ©Ÿèƒ½ç„¡åŠ¹åŒ–**ï¼ˆ4æ™‚é–“ä»¥å†…ï¼‰
   - å•é¡Œã®ã‚ã‚‹æ–°æ©Ÿèƒ½ã®ã¿ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ•ãƒ©ã‚°ã§ç„¡åŠ¹åŒ–
   - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®å½±éŸ¿ã‚’æœ€å°é™ã«æŠ‘åˆ¶
   - æ—¢å­˜æ©Ÿèƒ½ã®ç¶™ç¶šå‹•ä½œã‚’ä¿è¨¼

3. **å®Œå…¨å¾©æ—§**ï¼ˆ24æ™‚é–“ä»¥å†…ï¼‰
   - æ ¹æœ¬åŸå› ã®ç‰¹å®šã¨ä¿®æ­£
   - æ®µéšçš„ãªæ©Ÿèƒ½å¾©æ—§
   - åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã®å†å®Ÿè¡Œ

---

## 13. ä»˜éŒ²
| ç”¨èª | å®šç¾© |
|------|------|
| ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›† | ãƒšãƒ¼ã‚¸é·ç§»ãªã—ã«è¦ç´ ã‚’ç›´æ¥ç·¨é›†ã™ã‚‹æ©Ÿèƒ½ |
| PlantUML | ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ã®UMLå›³ä½œæˆãƒ„ãƒ¼ãƒ« |
| AST | Abstract Syntax Treeï¼ˆæŠ½è±¡æ§‹æ–‡æœ¨ï¼‰ |
| ãƒ‡ãƒã‚¦ãƒ³ã‚¹ | é€£ç¶šã™ã‚‹å‡¦ç†å‘¼ã³å‡ºã—ã‚’åˆ¶é™ã™ã‚‹æŠ€è¡“ |
| CSP | Content Security Policyï¼ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼ï¼‰ |

### B. å‚è€ƒè³‡æ–™
- PlantUMLå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: https://plantuml.com/
- Web Componentsä»•æ§˜: https://www.w3.org/TR/components-intro/
- WCAG 2.1 ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³: https://www.w3.org/WAI/WCAG21/quickref/

### C. å¤‰æ›´å±¥æ­´
| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | æ—¥ä»˜ | å¤‰æ›´å†…å®¹ | æ‹…å½“è€… |
|------------|------|----------|--------|
| 1.0 | 2025-08-15 | åˆç‰ˆä½œæˆ | software-doc-writer |
| 1.1 | 2025-08-15 | å®Ÿè£…æ¤œè¨¼ã¨è¿½åŠ è¦ä»¶ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³11ï¼‰è¿½åŠ ã€‚å®Œå…¨å®Ÿè£…ã‚³ãƒ¼ãƒ‰ä¾‹ã‚’å«ã‚€ä¾¡å€¤ææ¡ˆå®Ÿç¾å¯èƒ½æ€§è©•ä¾¡ã‚’çµ±åˆã€‚ç§»è¡Œè¨ˆç”»ã¨ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥ã‚’æ›´æ–°ã€‚ | software-doc-writer |

---

**æ–‡æ›¸çµ‚äº†**