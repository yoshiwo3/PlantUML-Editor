# 真の原因特定レポート
作成日時: 2025-08-13 18:20

## エグゼクティブサマリー
PlantUMLエディタのフリーズ問題の真の原因を特定しました。
**RealtimeSyncManager.js**の同期的なパース処理がメインスレッドをブロックしています。

## 詳細分析

### 問題の発生メカニズム

1. **イベントチェーン**
   ```
   textarea入力 
   → RealtimeSyncManager.setupCodeTextAreaListener()のinputイベント
   → debouncedCodeToGUISync() 
   → syncCodeToGUI()
   → parseWithTimeout()
   → PlantUMLLexer/PlantUMLParser（同期処理）
   → フリーズ
   ```

2. **問題箇所の詳細**
   - **ファイル**: RealtimeSyncManager.js
   - **行番号**: 755-779
   - **関数**: parseWithTimeout()
   - **問題のコード**:
     ```javascript
     // 同期的なパース処理がメインスレッドをブロック
     const lexer = new window.PlantUMLLexer(repairedCode);
     lexer.tokenize();
     const parser = new window.PlantUMLParser(lexer.tokens);
     const ast = parser.parse();
     ```

3. **セーフモードが効かない理由**
   - RealtimeSyncManagerは独立して動作
   - SafeMode.jsの制限が適用される前に処理が実行される
   - textareaへの直接的なイベントバインディング

### なぜ新規モジュールが機能しなかったか

1. **実行順序の問題**
   - RealtimeSyncManagerが先に初期化される
   - IntegrationManagerのセーフモードチェックが後から実行
   - イベントハンドラーの優先順位が低い

2. **ID不一致**
   - IntegrationManager: `getElementById('textarea')`を探索
   - 実際のID: `plantuml-code`
   - イベントハンドラーが設定されない

## 解決策

### 即時対応（緊急修正）
1. RealtimeSyncManagerのイベントリスナーを無効化
2. PlantUMLLexer/Parserの呼び出しを非同期化
3. Web Workerでパース処理を実行

### コード修正案

```javascript
// RealtimeSyncManager.js の修正
async parseWithTimeout(code, timeout = 5000) {
    // Web Workerで非同期実行
    if (window.asyncParser) {
        return await window.asyncParser.parse(code);
    }
    
    // フォールバック: requestIdleCallbackを使用
    return new Promise((resolve) => {
        requestIdleCallback(() => {
            // パース処理
        });
    });
}
```

## 推奨アクション

1. **即座に実施**
   - RealtimeSyncManagerのsetupCodeTextAreaListener()をコメントアウト
   - AsyncParser.jsを使用するよう変更

2. **短期対応**
   - すべてのパース処理をWeb Workerに移行
   - 同期的な処理を完全に排除

3. **長期対応**
   - アーキテクチャの再設計
   - イベント駆動型からメッセージパッシング型へ

## 結論
問題の根本原因は**RealtimeSyncManager.js**の同期的なパース処理です。
この処理がメインスレッドを完全にブロックし、ブラウザがフリーズします。
セーフモードも新規モジュールも、この処理より後に実行されるため効果がありませんでした。