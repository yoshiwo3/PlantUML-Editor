/**
 * PlantUMLParser.js
 * 
 * PlantUMLコードを解析し、構造化データに変換するパーサークラス
 * Phase 2: モジュール化改善版
 * 
 * @version 2.0.0
 * @date 2025-08-13
 */

class PlantUMLParser {
    constructor(options = {}) {
        this.strictMode = options.strictMode || false;
        this.locale = options.locale || 'ja';
        this.debugMode = options.debugMode || false;
        this.patterns = this.initializePatterns();
        this.parseHandlers = this.initializeHandlers();
    }

    /**
     * 正規表現パターンの初期化
     */
    initializePatterns() {
        return {
            // アクター定義パターン（Unicode対応）
            actorWithAlias: /^(?:actor|participant|database|entity|boundary|control)\s+(?:"([^"]+)"|'([^']+)'|`([^`]+)`|([^\s]+))\s+as\s+(?:"([^"]+)"|'([^']+)'|`([^`]+)`|([^\s]+))$/u,
            simpleActor: /^(?:actor|participant|database|entity|boundary|control)\s+(?:"([^"]+)"|'([^']+)'|`([^`]+)`|([^\s]+))$/u,
            
            // メッセージパターン（全矢印タイプ対応）
            message: /^(?:"([^"]+)"|'([^']+)'|`([^`]+)`|([^\s]+))\s*(<?-->>?|<?->|\.\.>>?|\.\.>|<<?--?|<<?\.\.?)\s*(?:"([^"]+)"|'([^']+)'|`([^`]+)`|([^\s]+))\s*:\s*(.+)$/u,
            
            // 構造パターン
            loop: /^loop\s+(.+)$/u,
            alt: /^alt\s+(.+)$/u,
            opt: /^opt\s+(.+)$/u,
            par: /^par$/u,
            else: /^else(?:\s+(.+))?$/u,
            end: /^end$/u,
            
            // ノートパターン
            note: /^note\s+(left|right|over)\s+(?:of\s+)?(?:"([^"]+)"|'([^']+)'|`([^`]+)`|([^\s]+))\s*:\s*(.+)$/u,
            
            // アクティベーション
            activate: /^(activate|deactivate)\s+(?:"([^"]+)"|'([^']+)'|`([^`]+)`|([^\s]+))$/u,
            
            // グループ
            group: /^group\s+(.+)$/u,
            
            // 区切り線
            divider: /^==\s*(.+)\s*==$/u,
            
            // 遅延
            delay: /^\.\.\.(.*)\.\.\.$/u,
            
            // リターン
            return: /^return\s+(.*)$/u,
            
            // PlantUML開始終了
            startuml: /^@startuml/,
            enduml: /^@enduml/,
            
            // タイトル
            title: /^title\s+(.+)$/u,
            
            // autonumber
            autonumber: /^autonumber(?:\s+(\d+))?$/
        };
    }

    /**
     * パースハンドラーの初期化
     */
    initializeHandlers() {
        return {
            actor: this.handleActor.bind(this),
            message: this.handleMessage.bind(this),
            structure: this.handleStructure.bind(this),
            note: this.handleNote.bind(this),
            activation: this.handleActivation.bind(this)
        };
    }

    /**
     * デバッグログ出力
     */
    log(message, data = null) {
        if (this.debugMode || (typeof localStorage !== 'undefined' && localStorage.getItem('debug_parse') === 'true')) {
            console.group(`[PlantUMLParser] ${message}`);
            if (data) console.log(data);
            console.groupEnd();
        }
    }

    /**
     * メインパース関数
     */
    parse(code) {
        this.log('Starting parse', { codeLength: code.length });
        
        // 前処理
        const lines = this.preprocessCode(code);
        
        // パースコンテキストの初期化
        const context = this.createParseContext();
        
        // 各行の解析
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            context.lineNumber = i + 1;
            this.parseLine(line, context);
        }
        
        // 結果の構築
        const result = this.buildResult(context);
        
        this.log('Parse complete', {
            actorCount: result.actors.length,
            actionCount: result.actions.length,
            noteCount: result.notes?.length || 0
        });
        
        return result;
    }

    /**
     * コードの前処理
     */
    preprocessCode(code) {
        // 改行コードの正規化
        const normalized = code.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        
        // 行に分割してトリム
        const lines = normalized.split('\n').map(line => line.trim());
        
        // コメント行の除去（'で始まる行）
        return lines.filter(line => !line.startsWith("'") && !line.startsWith("#'"));
    }

    /**
     * パースコンテキストの作成
     */
    createParseContext() {
        return {
            actors: [],
            actions: [],
            notes: [],
            actorMap: new Map(), // エイリアス -> 実名のマッピング
            structures: [],
            currentStructure: null,
            inLoop: false,
            inCondition: false,
            inParallel: false,
            inGroup: false,
            lineNumber: 0,
            hasStartUml: false,
            hasEndUml: false,
            title: null,
            autoNumber: false,
            autoNumberStart: 1,
            activations: new Map() // アクター -> アクティベーション状態
        };
    }

    /**
     * 1行をパース
     */
    parseLine(line, context) {
        // 空行はスキップ
        if (!line) return;
        
        // @startuml/@enduml のチェック
        if (this.patterns.startuml.test(line)) {
            context.hasStartUml = true;
            return;
        }
        if (this.patterns.enduml.test(line)) {
            context.hasEndUml = true;
            return;
        }
        
        // タイトル
        const titleMatch = line.match(this.patterns.title);
        if (titleMatch) {
            context.title = titleMatch[1];
            return;
        }
        
        // autonumber
        const autonumberMatch = line.match(this.patterns.autonumber);
        if (autonumberMatch) {
            context.autoNumber = true;
            if (autonumberMatch[1]) {
                context.autoNumberStart = parseInt(autonumberMatch[1]);
            }
            return;
        }
        
        // アクター定義
        if (this.tryParseActor(line, context)) return;
        
        // 構造制御
        if (this.tryParseStructure(line, context)) return;
        
        // メッセージ
        if (this.tryParseMessage(line, context)) return;
        
        // ノート
        if (this.tryParseNote(line, context)) return;
        
        // アクティベーション
        if (this.tryParseActivation(line, context)) return;
        
        // その他の要素
        if (this.tryParseOther(line, context)) return;
        
        // パースできなかった行
        this.log('Unparsed line', { lineNumber: context.lineNumber, line });
    }

    /**
     * アクター定義の解析
     */
    tryParseActor(line, context) {
        // エイリアス付き定義
        const aliasMatch = line.match(this.patterns.actorWithAlias);
        if (aliasMatch) {
            const name = aliasMatch[1] || aliasMatch[2] || aliasMatch[3] || aliasMatch[4];
            const alias = aliasMatch[5] || aliasMatch[6] || aliasMatch[7] || aliasMatch[8];
            
            context.actors.push(name);
            context.actorMap.set(alias, name);
            
            this.log('Found actor with alias', { name, alias });
            return true;
        }
        
        // シンプル定義
        const simpleMatch = line.match(this.patterns.simpleActor);
        if (simpleMatch) {
            const name = simpleMatch[1] || simpleMatch[2] || simpleMatch[3] || simpleMatch[4];
            
            context.actors.push(name);
            context.actorMap.set(name, name);
            
            this.log('Found simple actor', { name });
            return true;
        }
        
        return false;
    }

    /**
     * 構造制御の解析
     */
    tryParseStructure(line, context) {
        // ループ
        const loopMatch = line.match(this.patterns.loop);
        if (loopMatch) {
            context.inLoop = true;
            context.currentStructure = {
                type: 'loop',
                condition: loopMatch[1],
                actions: []
            };
            this.log('Starting loop', { condition: loopMatch[1] });
            return true;
        }
        
        // 条件分岐
        const altMatch = line.match(this.patterns.alt);
        if (altMatch) {
            context.inCondition = true;
            context.currentStructure = {
                type: 'condition',
                conditionType: 'alt',
                conditionName: altMatch[1],
                trueBranch: [],
                falseBranch: [],
                currentBranch: 'true'
            };
            this.log('Starting alt condition', { condition: altMatch[1] });
            return true;
        }
        
        // オプション
        const optMatch = line.match(this.patterns.opt);
        if (optMatch) {
            context.inCondition = true;
            context.currentStructure = {
                type: 'condition',
                conditionType: 'opt',
                conditionName: optMatch[1],
                trueBranch: [],
                falseBranch: [],
                currentBranch: 'true'
            };
            this.log('Starting opt condition', { condition: optMatch[1] });
            return true;
        }
        
        // 並行処理
        if (this.patterns.par.test(line)) {
            context.inParallel = true;
            context.currentStructure = {
                type: 'parallel',
                branches: [[]]
            };
            this.log('Starting parallel');
            return true;
        }
        
        // グループ
        const groupMatch = line.match(this.patterns.group);
        if (groupMatch) {
            context.inGroup = true;
            context.currentStructure = {
                type: 'group',
                label: groupMatch[1],
                actions: []
            };
            this.log('Starting group', { label: groupMatch[1] });
            return true;
        }
        
        // else
        const elseMatch = line.match(this.patterns.else);
        if (elseMatch) {
            if (context.inCondition && context.currentStructure) {
                context.currentStructure.currentBranch = 'false';
                if (elseMatch[1]) {
                    context.currentStructure.elseCondition = elseMatch[1];
                }
                this.log('Else branch', { condition: elseMatch[1] });
            } else if (context.inParallel && context.currentStructure) {
                context.currentStructure.branches.push([]);
                this.log('New parallel branch');
            }
            return true;
        }
        
        // end
        if (this.patterns.end.test(line)) {
            if (context.currentStructure) {
                context.actions.push(context.currentStructure);
                context.currentStructure = null;
                context.inLoop = false;
                context.inCondition = false;
                context.inParallel = false;
                context.inGroup = false;
                this.log('Ending structure');
            }
            return true;
        }
        
        return false;
    }

    /**
     * メッセージの解析
     */
    tryParseMessage(line, context) {
        const match = line.match(this.patterns.message);
        if (!match) return false;
        
        // マッチグループから値を取得
        const fromDouble = match[1];
        const fromSingle = match[2];
        const fromBacktick = match[3];
        const fromPlain = match[4];
        const arrow = match[5];
        const toDouble = match[6];
        const toSingle = match[7];
        const toBacktick = match[8];
        const toPlain = match[9];
        const text = match[10];
        
        // 送信元と送信先を決定
        const fromName = fromDouble || fromSingle || fromBacktick || fromPlain;
        const toName = toDouble || toSingle || toBacktick || toPlain;
        
        // エイリアスから実名を解決
        const from = context.actorMap.get(fromName) || fromName;
        const to = context.actorMap.get(toName) || toName;
        
        // メッセージの属性を判定
        const isAsync = arrow.includes('--') || arrow.includes('..');
        const isReturn = arrow.includes('<');
        const isDotted = arrow.includes('..');
        const isUncertain = text.includes('？') || text.includes('?');
        const cleanText = text.replace(/[？?]$/, '').trim();
        
        // アクション オブジェクトを作成
        const action = {
            from,
            to,
            text: cleanText,
            arrow,
            async: isAsync,
            return: isReturn,
            dotted: isDotted,
            uncertain: isUncertain
        };
        
        // 自動番号付けが有効な場合
        if (context.autoNumber) {
            action.number = context.autoNumberStart++;
        }
        
        this.log('Found message', { from, to, text: cleanText, arrow });
        
        // 構造内のアクションか通常のアクションかを判定
        if (context.inLoop && context.currentStructure) {
            context.currentStructure.actions.push(action);
        } else if (context.inCondition && context.currentStructure) {
            if (context.currentStructure.currentBranch === 'true') {
                context.currentStructure.trueBranch.push(action);
            } else {
                context.currentStructure.falseBranch.push(action);
            }
        } else if (context.inParallel && context.currentStructure) {
            const lastBranch = context.currentStructure.branches.length - 1;
            context.currentStructure.branches[lastBranch].push(action);
        } else if (context.inGroup && context.currentStructure) {
            context.currentStructure.actions.push(action);
        } else {
            context.actions.push(action);
        }
        
        return true;
    }

    /**
     * ノートの解析
     */
    tryParseNote(line, context) {
        const match = line.match(this.patterns.note);
        if (!match) return false;
        
        const position = match[1];
        const target = match[2] || match[3] || match[4] || match[5];
        const text = match[6];
        
        const note = {
            type: 'note',
            position,
            target: context.actorMap.get(target) || target,
            text
        };
        
        context.notes.push(note);
        this.log('Found note', note);
        
        return true;
    }

    /**
     * アクティベーションの解析
     */
    tryParseActivation(line, context) {
        const match = line.match(this.patterns.activate);
        if (!match) return false;
        
        const action = match[1];
        const target = match[2] || match[3] || match[4] || match[5];
        const actor = context.actorMap.get(target) || target;
        
        if (action === 'activate') {
            context.activations.set(actor, true);
            this.log('Activated', { actor });
        } else {
            context.activations.set(actor, false);
            this.log('Deactivated', { actor });
        }
        
        return true;
    }

    /**
     * その他の要素の解析
     */
    tryParseOther(line, context) {
        // 区切り線
        const dividerMatch = line.match(this.patterns.divider);
        if (dividerMatch) {
            context.actions.push({
                type: 'divider',
                text: dividerMatch[1]
            });
            this.log('Found divider', { text: dividerMatch[1] });
            return true;
        }
        
        // 遅延
        const delayMatch = line.match(this.patterns.delay);
        if (delayMatch) {
            context.actions.push({
                type: 'delay',
                text: delayMatch[1] || ''
            });
            this.log('Found delay', { text: delayMatch[1] });
            return true;
        }
        
        // リターン
        const returnMatch = line.match(this.patterns.return);
        if (returnMatch) {
            context.actions.push({
                type: 'return',
                text: returnMatch[1] || ''
            });
            this.log('Found return', { text: returnMatch[1] });
            return true;
        }
        
        return false;
    }

    /**
     * パース結果の構築
     */
    buildResult(context) {
        // アクターの重複を除去
        const uniqueActors = [...new Set(context.actors)];
        
        // 結果オブジェクトを構築
        const result = {
            actors: uniqueActors,
            actions: context.actions,
            title: context.title,
            hasValidStructure: context.hasStartUml && context.hasEndUml
        };
        
        // ノートがある場合は追加
        if (context.notes.length > 0) {
            result.notes = context.notes;
        }
        
        // アクティベーション情報がある場合は追加
        if (context.activations.size > 0) {
            result.activations = Object.fromEntries(context.activations);
        }
        
        // 自動番号付けが有効な場合
        if (context.autoNumber) {
            result.autoNumber = true;
        }
        
        return result;
    }

    /**
     * エラー処理付きパース
     */
    safeParse(code) {
        try {
            const result = this.parse(code);
            if (!result || !result.actors) {
                this.log('Parse failed, using fallback');
                return this.getFallbackResult(code);
            }
            return result;
        } catch (error) {
            this.log('Parse error', { error: error.message, stack: error.stack });
            return this.getFallbackResult(code);
        }
    }

    /**
     * フォールバック結果の生成
     */
    getFallbackResult(code) {
        this.log('Generating fallback result');
        
        const actors = [];
        const actions = [];
        
        // 簡易的にアクターを抽出
        const actorRegex = /(?:actor|participant|database|entity|boundary|control)\s+(?:"([^"]+)"|'([^']+)'|`([^`]+)`|([^\s]+))/g;
        let match;
        while ((match = actorRegex.exec(code)) !== null) {
            const actor = match[1] || match[2] || match[3] || match[4];
            if (actor && !actors.includes(actor)) {
                actors.push(actor);
            }
        }
        
        // 簡易的にメッセージを抽出
        const messageRegex = /(?:"([^"]+)"|'([^']+)'|([^\s]+))\s*(?:->|-->|\.\.>)\s*(?:"([^"]+)"|'([^']+)'|([^\s]+))\s*:\s*(.+)/g;
        while ((match = messageRegex.exec(code)) !== null) {
            const from = match[1] || match[2] || match[3];
            const to = match[4] || match[5] || match[6];
            const text = match[7];
            if (from && to && text) {
                actions.push({ from, to, text });
            }
        }
        
        return {
            actors,
            actions,
            hasValidStructure: code.includes('@startuml') && code.includes('@enduml'),
            isFallback: true
        };
    }

    /**
     * バリデーション
     */
    validate(code) {
        const errors = [];
        const warnings = [];
        
        // @startuml/@enduml チェック
        if (!code.includes('@startuml')) {
            errors.push('Missing @startuml');
        }
        if (!code.includes('@enduml')) {
            errors.push('Missing @enduml');
        }
        
        // パース試行
        try {
            const result = this.parse(code);
            
            // アクターチェック
            if (result.actors.length === 0) {
                warnings.push('No actors defined');
            }
            
            // アクションチェック
            if (result.actions.length === 0) {
                warnings.push('No actions defined');
            }
            
            // 未定義アクターの使用チェック
            const definedActors = new Set(result.actors);
            for (const action of result.actions) {
                if (action.from && !definedActors.has(action.from)) {
                    warnings.push(`Undefined actor: ${action.from}`);
                }
                if (action.to && !definedActors.has(action.to)) {
                    warnings.push(`Undefined actor: ${action.to}`);
                }
            }
            
        } catch (error) {
            errors.push(`Parse error: ${error.message}`);
        }
        
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }

    handleActor(line) {
        this.log('handleActor called', { line });
        return { type: 'actor', content: line };
    }

    handleMessage(line) {
        this.log('handleMessage called', { line });
        return { type: 'message', content: line };
    }

    handleStructure(line) {
        this.log('handleStructure called', { line });
        return { type: 'structure', content: line };
    }

    handleNote(line) {
        this.log('handleNote called', { line });
        return { type: 'note', content: line };
    }

    handleActivation(line) {
        this.log('handleActivation called', { line });
        return { type: 'activation', content: line };
    }
}

// エクスポート（ES6モジュール対応）
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PlantUMLParser;
}

// ブラウザグローバル対応
if (typeof window !== 'undefined') {
    window.PlantUMLParser = PlantUMLParser;
}