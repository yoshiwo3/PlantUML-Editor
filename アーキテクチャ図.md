# PlantUML統合アプリケーション アーキテクチャ図

**作成日**: 2025年1月14日  
**バージョン**: 1.0  
**目的**: 統合後のシステムアーキテクチャの可視化

## 現在のアーキテクチャ（As-Is）

```mermaid
graph TB
    subgraph "jp2plantuml（動作中）"
        A1[Browser] --> A2[Vanilla JS Frontend]
        A2 --> A3[Express Server:8086]
        A3 --> A4[PlantUML Converter]
        A3 --> A5[Static Files]
    end
    
    subgraph "PlantUML_Editor_Proto（未完成）"
        B1[Browser] -.-> B2[React App:3000]
        B2 -.-> B3[Node Server]
        B3 -.-> B4[未実装]
    end
    
    style B1 stroke-dasharray: 5 5
    style B2 stroke-dasharray: 5 5
    style B3 stroke-dasharray: 5 5
    style B4 stroke-dasharray: 5 5
```

## 統合後のアーキテクチャ（To-Be）

```mermaid
graph TB
    subgraph "Client Layer"
        C1[Web Browser]
        C2[Mobile Browser]
    end
    
    subgraph "Frontend Layer"
        F1[Static Assets<br/>HTML/CSS/JS]
        F2[Core UI<br/>Vanilla JavaScript]
        F3[Enhanced Components<br/>React Optional]
        F4[Real-time Updates<br/>WebSocket Client]
    end
    
    subgraph "API Gateway"
        G1[Express Router :8086]
        G2[CORS Middleware]
        G3[Auth Middleware]
        G4[Rate Limiter]
    end
    
    subgraph "Application Layer"
        A1[PlantUML Converter Service]
        A2[Japanese Parser]
        A3[Diagram Generator]
        A4[Cache Manager]
        A5[WebSocket Server]
    end
    
    subgraph "Data Layer"
        D1[Session Store<br/>Redis/Memory]
        D2[File Storage<br/>Local/S3]
        D3[Configuration<br/>ENV Variables]
    end
    
    subgraph "Infrastructure"
        I1[Docker Container]
        I2[Node.js Runtime]
        I3[PM2 Process Manager]
    end
    
    C1 --> F1
    C2 --> F1
    F1 --> F2
    F2 --> G1
    F3 -.-> G1
    F4 <--> A5
    
    G1 --> G2
    G2 --> G3
    G3 --> G4
    G4 --> A1
    
    A1 --> A2
    A2 --> A3
    A1 --> A4
    A4 --> D1
    A3 --> D2
    
    A1 --> D3
    
    I1 --> I2
    I2 --> I3
    I3 --> G1
    I3 --> A1
    
    style F3 stroke-dasharray: 5 5
```

## コンポーネント相互作用図

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant A as API Server
    participant C as Converter
    participant W as WebSocket
    
    U->>F: 日本語テキスト入力
    F->>A: POST /api/convert
    A->>C: 変換リクエスト
    C->>C: 日本語解析
    C->>C: PlantUML生成
    C-->>A: PlantUMLコード
    A-->>F: 変換結果
    F->>F: プレビュー更新
    
    Note over W: リアルタイム更新
    F->>W: WebSocket接続
    W-->>F: 自動更新通知
```

## データフロー図

```mermaid
graph LR
    subgraph "Input"
        I1[日本語テキスト]
        I2[PlantUMLコード]
    end
    
    subgraph "Processing"
        P1[テキスト解析]
        P2[構造認識]
        P3[PlantUML変換]
        P4[画像生成]
    end
    
    subgraph "Output"
        O1[PlantUMLコード]
        O2[SVG/PNG画像]
        O3[エラーメッセージ]
    end
    
    I1 --> P1
    P1 --> P2
    P2 --> P3
    P3 --> O1
    P3 --> P4
    P4 --> O2
    
    I2 --> P4
    
    P1 -.-> O3
    P3 -.-> O3
    P4 -.-> O3
```

## デプロイメントアーキテクチャ

```mermaid
graph TB
    subgraph "Development"
        D1[Local Docker]
        D2[Hot Reload]
        D3[Debug Tools]
    end
    
    subgraph "Staging"
        S1[Docker Compose]
        S2[Test Data]
        S3[Monitoring]
    end
    
    subgraph "Production"
        P1[Docker Swarm/K8s]
        P2[Load Balancer]
        P3[Auto Scaling]
        P4[CDN]
    end
    
    D1 --> S1
    S1 --> P1
    P2 --> P1
    P4 --> P1
```

## システム層構成

```mermaid
graph TD
    subgraph "Presentation Layer"
        PL1[HTML/CSS]
        PL2[JavaScript]
        PL3[React Components]
    end
    
    subgraph "Application Layer"
        AL1[Express.js]
        AL2[API Routes]
        AL3[Middleware]
        AL4[WebSocket Handler]
    end
    
    subgraph "Business Logic Layer"
        BL1[PlantUML Converter]
        BL2[Japanese Parser]
        BL3[Validation Service]
        BL4[Cache Service]
    end
    
    subgraph "Data Access Layer"
        DAL1[File System]
        DAL2[Redis Client]
        DAL3[Config Manager]
    end
    
    subgraph "Infrastructure Layer"
        IL1[Docker]
        IL2[Node.js]
        IL3[Nginx]
        IL4[PM2]
    end
    
    PL1 --> AL1
    PL2 --> AL1
    PL3 --> AL1
    
    AL1 --> BL1
    AL2 --> BL2
    AL3 --> BL3
    AL4 --> BL4
    
    BL1 --> DAL1
    BL4 --> DAL2
    BL3 --> DAL3
    
    DAL1 --> IL1
    DAL2 --> IL1
    DAL3 --> IL2
```

## API エンドポイント構成

```mermaid
graph LR
    subgraph "API Routes"
        R1["/api/convert"]
        R2["/api/validate"]
        R3["/api/export"]
        R4["/api/health"]
        R5["/api/metrics"]
    end
    
    subgraph "HTTP Methods"
        M1[POST]
        M2[GET]
        M3[PUT]
        M4[DELETE]
    end
    
    subgraph "Responses"
        RE1[200 OK]
        RE2[400 Bad Request]
        RE3[500 Server Error]
        RE4[404 Not Found]
    end
    
    M1 --> R1
    M2 --> R4
    M2 --> R5
    M1 --> R2
    M1 --> R3
    
    R1 --> RE1
    R1 --> RE2
    R1 --> RE3
    R4 --> RE1
```

## セキュリティアーキテクチャ

```mermaid
graph TB
    subgraph "Security Layers"
        SL1[HTTPS/TLS]
        SL2[CORS Policy]
        SL3[Rate Limiting]
        SL4[Input Validation]
        SL5[XSS Protection]
        SL6[CSRF Protection]
    end
    
    subgraph "Authentication"
        AU1[JWT Tokens]
        AU2[Session Management]
        AU3[API Keys]
    end
    
    subgraph "Authorization"
        AZ1[Role-Based Access]
        AZ2[Resource Permissions]
        AZ3[Rate Limits]
    end
    
    SL1 --> AU1
    SL2 --> AU2
    SL3 --> AZ3
    SL4 --> AZ1
    
    AU1 --> AZ1
    AU2 --> AZ2
    AU3 --> AZ3
```

## 技術スタック概要

| レイヤー | 技術 | 用途 |
|---------|------|------|
| **Frontend** | Vanilla JS (主) + React (補助) | UI実装 |
| **Backend** | Node.js + Express | APIサーバー |
| **Real-time** | Socket.io / WebSocket | リアルタイム通信 |
| **Container** | Docker + Docker Compose | コンテナ化 |
| **Process** | PM2 | プロセス管理 |
| **Cache** | Redis / In-Memory | キャッシング |
| **Storage** | Local FS / S3 | ファイル保存 |
| **CI/CD** | GitHub Actions | 自動化パイプライン |
| **Testing** | Jest + Playwright | 自動テスト |
| **Monitoring** | Prometheus + Grafana | 監視・可視化 |

## パフォーマンス最適化ポイント

```mermaid
graph TD
    subgraph "Frontend Optimization"
        FO1[Code Splitting]
        FO2[Lazy Loading]
        FO3[Asset Compression]
        FO4[CDN Distribution]
    end
    
    subgraph "Backend Optimization"
        BO1[Response Caching]
        BO2[Database Indexing]
        BO3[Connection Pooling]
        BO4[Load Balancing]
    end
    
    subgraph "Infrastructure Optimization"
        IO1[Container Optimization]
        IO2[Resource Limits]
        IO3[Auto Scaling]
        IO4[Health Checks]
    end
    
    FO1 --> Performance[高速レスポンス]
    BO1 --> Performance
    IO1 --> Performance
```

## スケーラビリティ戦略

```mermaid
graph LR
    subgraph "Horizontal Scaling"
        HS1[App Instances]
        HS2[Load Balancer]
        HS3[Database Replicas]
    end
    
    subgraph "Vertical Scaling"
        VS1[CPU Upgrade]
        VS2[Memory Increase]
        VS3[Storage Expansion]
    end
    
    subgraph "Caching Strategy"
        CS1[Redis Cache]
        CS2[CDN Cache]
        CS3[Browser Cache]
    end
    
    HS1 --> Scale[スケーラビリティ]
    VS1 --> Scale
    CS1 --> Scale
```

---

**更新履歴**:
- 2025/01/14: 初版作成
- 統合アーキテクチャの定義
- コンポーネント図の作成
- データフロー図の追加